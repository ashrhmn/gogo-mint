"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/v1/contract/collection721";
exports.ids = ["pages/api/v1/contract/collection721"];
exports.modules = {

/***/ "@prisma/client":
/*!*********************************!*\
  !*** external "@prisma/client" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@prisma/client");

/***/ }),

/***/ "axios":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

module.exports = require("axios");

/***/ }),

/***/ "cookies":
/*!**************************!*\
  !*** external "cookies" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("cookies");

/***/ }),

/***/ "crypto-js":
/*!****************************!*\
  !*** external "crypto-js" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("crypto-js");

/***/ }),

/***/ "solc":
/*!***********************!*\
  !*** external "solc" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("solc");

/***/ }),

/***/ "next-connect":
/*!*******************************!*\
  !*** external "next-connect" ***!
  \*******************************/
/***/ ((module) => {

module.exports = import("next-connect");;

/***/ }),

/***/ "(api)/./constants/configuration.ts":
/*!************************************!*\
  !*** ./constants/configuration.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ACCESS_TOKEN_COOKIE_KEY\": () => (/* binding */ ACCESS_TOKEN_COOKIE_KEY),\n/* harmony export */   \"CRYPTO_SECRET\": () => (/* binding */ CRYPTO_SECRET),\n/* harmony export */   \"DEFAULT_CHAIN\": () => (/* binding */ DEFAULT_CHAIN),\n/* harmony export */   \"DISCORD_AUTH_URL\": () => (/* binding */ DISCORD_AUTH_URL),\n/* harmony export */   \"DISCORD_OAUTH_CLIENT_ID\": () => (/* binding */ DISCORD_OAUTH_CLIENT_ID),\n/* harmony export */   \"DISCORD_OAUTH_CLIENT_SECRET\": () => (/* binding */ DISCORD_OAUTH_CLIENT_SECRET),\n/* harmony export */   \"ENV_PROTOCOL\": () => (/* binding */ ENV_PROTOCOL),\n/* harmony export */   \"isDevelopment\": () => (/* binding */ isDevelopment)\n/* harmony export */ });\nconst DEFAULT_CHAIN = {\n    id: 4,\n    name: \"Rinkeby\"\n};\nconst ACCESS_TOKEN_COOKIE_KEY = \"Nqr#3FEd6uY}]aP\";\nconst ENV_PROTOCOL =  false ? 0 : \"http\";\nconst CRYPTO_SECRET = process.env.CRYPTO_SECRET || \"FNmag3vLrqKng4tP2LdnmsEDffPfxHygjH9DC6N9AhL7RgcfPjeWyzGcgnWL\";\nconst DISCORD_OAUTH_CLIENT_ID = process.env.DISCORD_OAUTH_CLIENT_ID || \"892427349927280732\";\nconst DISCORD_OAUTH_CLIENT_SECRET = process.env.DISCORD_OAUTH_CLIENT_SECRET || \"zKxjMkC-GmD8J0gvrZm3yKSEqnBS8LhE\";\nconst isDevelopment = \"development\" != \"production\";\nconst DISCORD_AUTH_URL = isDevelopment ? `https://discord.com/oauth2/authorize?client_id=992820231242268723&redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fapi%2Fv1%2Fauth%2Fdiscord%2Fredirect&response_type=code&scope=identify` : `https://discord.com/api/oauth2/authorize?client_id=992820231242268723&redirect_uri=https%3A%2F%2F${process.env.NEXT_PUBLIC_HOST_ROOT || \"gogo-mint.ashrhmn.com\"}%2Fapi%2Fv1%2Fauth%2Fdiscord%2Fredirect&response_type=code&scope=identify`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9jb25zdGFudHMvY29uZmlndXJhdGlvbi50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFPLE1BQU1BLGFBQWEsR0FBRztJQUFFQyxFQUFFLEVBQUUsQ0FBQztJQUFFQyxJQUFJLEVBQUUsU0FBUztDQUFFLENBQUM7QUFFakQsTUFBTUMsdUJBQXVCLEdBQUcsaUJBQWlCLENBQUM7QUFFbEQsTUFBTUMsWUFBWSxHQUN2QkMsTUFBcUMsR0FBRyxDQUFPLEdBQUcsTUFBTSxDQUFDO0FBRXBELE1BQU1DLGFBQWEsR0FDeEJELE9BQU8sQ0FBQ0UsR0FBRyxDQUFDRCxhQUFhLElBQ3pCLDhEQUE4RCxDQUFDO0FBRTFELE1BQU1FLHVCQUF1QixHQUNsQ0gsT0FBTyxDQUFDRSxHQUFHLENBQUNDLHVCQUF1QixJQUFJLG9CQUFvQixDQUFDO0FBRXZELE1BQU1DLDJCQUEyQixHQUN0Q0osT0FBTyxDQUFDRSxHQUFHLENBQUNFLDJCQUEyQixJQUFJLGtDQUFrQyxDQUFDO0FBRXpFLE1BQU1DLGFBQWEsR0FBR0wsYUFqQmhCLElBaUJ3QyxZQUFZLENBQUM7QUFFM0QsTUFBTU0sZ0JBQWdCLEdBQUdELGFBQWEsR0FDekMsQ0FBQyxxTEFBcUwsQ0FBQyxHQUN2TCxDQUFDLGlHQUFpRyxFQUNoR0wsT0FBTyxDQUFDRSxHQUFHLENBQUNLLHFCQUFxQixJQUFJLHVCQUF1QixDQUM3RCx5RUFBeUUsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vY29uc3RhbnRzL2NvbmZpZ3VyYXRpb24udHM/MDIwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgREVGQVVMVF9DSEFJTiA9IHsgaWQ6IDQsIG5hbWU6IFwiUmlua2VieVwiIH07XG5cbmV4cG9ydCBjb25zdCBBQ0NFU1NfVE9LRU5fQ09PS0lFX0tFWSA9IFwiTnFyIzNGRWQ2dVl9XWFQXCI7XG5cbmV4cG9ydCBjb25zdCBFTlZfUFJPVE9DT0wgPVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBcImh0dHBzXCIgOiBcImh0dHBcIjtcblxuZXhwb3J0IGNvbnN0IENSWVBUT19TRUNSRVQgPVxuICBwcm9jZXNzLmVudi5DUllQVE9fU0VDUkVUIHx8XG4gIFwiRk5tYWczdkxycUtuZzR0UDJMZG5tc0VEZmZQZnhIeWdqSDlEQzZOOUFoTDdSZ2NmUGplV3l6R2NnbldMXCI7XG5cbmV4cG9ydCBjb25zdCBESVNDT1JEX09BVVRIX0NMSUVOVF9JRCA9XG4gIHByb2Nlc3MuZW52LkRJU0NPUkRfT0FVVEhfQ0xJRU5UX0lEIHx8IFwiODkyNDI3MzQ5OTI3MjgwNzMyXCI7XG5cbmV4cG9ydCBjb25zdCBESVNDT1JEX09BVVRIX0NMSUVOVF9TRUNSRVQgPVxuICBwcm9jZXNzLmVudi5ESVNDT1JEX09BVVRIX0NMSUVOVF9TRUNSRVQgfHwgXCJ6S3hqTWtDLUdtRDhKMGd2clptM3lLU0VxbkJTOExoRVwiO1xuXG5leHBvcnQgY29uc3QgaXNEZXZlbG9wbWVudCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9IFwicHJvZHVjdGlvblwiO1xuXG5leHBvcnQgY29uc3QgRElTQ09SRF9BVVRIX1VSTCA9IGlzRGV2ZWxvcG1lbnRcbiAgPyBgaHR0cHM6Ly9kaXNjb3JkLmNvbS9vYXV0aDIvYXV0aG9yaXplP2NsaWVudF9pZD05OTI4MjAyMzEyNDIyNjg3MjMmcmVkaXJlY3RfdXJpPWh0dHAlM0ElMkYlMkZsb2NhbGhvc3QlM0EzMDAwJTJGYXBpJTJGdjElMkZhdXRoJTJGZGlzY29yZCUyRnJlZGlyZWN0JnJlc3BvbnNlX3R5cGU9Y29kZSZzY29wZT1pZGVudGlmeWBcbiAgOiBgaHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvb2F1dGgyL2F1dGhvcml6ZT9jbGllbnRfaWQ9OTkyODIwMjMxMjQyMjY4NzIzJnJlZGlyZWN0X3VyaT1odHRwcyUzQSUyRiUyRiR7XG4gICAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19IT1NUX1JPT1QgfHwgXCJnb2dvLW1pbnQuYXNocmhtbi5jb21cIlxuICAgIH0lMkZhcGklMkZ2MSUyRmF1dGglMkZkaXNjb3JkJTJGcmVkaXJlY3QmcmVzcG9uc2VfdHlwZT1jb2RlJnNjb3BlPWlkZW50aWZ5YDtcbiJdLCJuYW1lcyI6WyJERUZBVUxUX0NIQUlOIiwiaWQiLCJuYW1lIiwiQUNDRVNTX1RPS0VOX0NPT0tJRV9LRVkiLCJFTlZfUFJPVE9DT0wiLCJwcm9jZXNzIiwiQ1JZUFRPX1NFQ1JFVCIsImVudiIsIkRJU0NPUkRfT0FVVEhfQ0xJRU5UX0lEIiwiRElTQ09SRF9PQVVUSF9DTElFTlRfU0VDUkVUIiwiaXNEZXZlbG9wbWVudCIsIkRJU0NPUkRfQVVUSF9VUkwiLCJORVhUX1BVQkxJQ19IT1NUX1JPT1QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./constants/configuration.ts\n");

/***/ }),

/***/ "(api)/./controllers/codegen.controller.ts":
/*!*******************************************!*\
  !*** ./controllers/codegen.controller.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"get721CompiledContract\": () => (/* binding */ get721CompiledContract)\n/* harmony export */ });\n/* harmony import */ var _services_contract_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../services/contract.service */ \"(api)/./services/contract.service.ts\");\n/* harmony import */ var _services_solidity_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/solidity.service */ \"(api)/./services/solidity.service.ts\");\n/* harmony import */ var _utils_Response_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Response.utils */ \"(api)/./utils/Response.utils.ts\");\n/* harmony import */ var _utils_String_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/String.utils */ \"(api)/./utils/String.utils.ts\");\n\n\n\n\nconst get721CompiledContract = async (req, res)=>{\n    try {\n        const contractName = req.query.name;\n        const name = contractName && typeof contractName == \"string\" ? contractName : \"Collection721\";\n        //   console.log(\"name : \", name);\n        //   console.log(\"nzd name : \", normalizeString(name));\n        const code = (0,_services_contract_service__WEBPACK_IMPORTED_MODULE_0__.get721ContractCode)(name);\n        const initCode = (0,_services_solidity_service__WEBPACK_IMPORTED_MODULE_1__.getAbiEvmCodeFromSolidity)((0,_utils_String_utils__WEBPACK_IMPORTED_MODULE_3__.normalizeString)(name), code);\n        if (!initCode) return res.json((0,_utils_Response_utils__WEBPACK_IMPORTED_MODULE_2__.errorResponse)(\"Error compiling\"));\n        return res.json((0,_utils_Response_utils__WEBPACK_IMPORTED_MODULE_2__.successResponse)(initCode));\n    } catch (error) {\n        console.log(error);\n        return res.json((0,_utils_Response_utils__WEBPACK_IMPORTED_MODULE_2__.errorResponse)(\"Error compiling\"));\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9jb250cm9sbGVycy9jb2RlZ2VuLmNvbnRyb2xsZXIudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDa0U7QUFDTztBQUNBO0FBQ2pCO0FBRWpELE1BQU1LLHNCQUFzQixHQUFHLE9BQ3BDQyxHQUFtQixFQUNuQkMsR0FBb0IsR0FDakI7SUFDSCxJQUFJO1FBQ0YsTUFBTUMsWUFBWSxHQUFHRixHQUFHLENBQUNHLEtBQUssQ0FBQ0MsSUFBSTtRQUNuQyxNQUFNQSxJQUFJLEdBQ1JGLFlBQVksSUFBSSxPQUFPQSxZQUFZLElBQUksUUFBUSxHQUMzQ0EsWUFBWSxHQUNaLGVBQWU7UUFDckIsa0NBQWtDO1FBQ2xDLHVEQUF1RDtRQUN2RCxNQUFNRyxJQUFJLEdBQUdYLDhFQUFrQixDQUFDVSxJQUFJLENBQUM7UUFDckMsTUFBTUUsUUFBUSxHQUFHWCxxRkFBeUIsQ0FBQ0csb0VBQWUsQ0FBQ00sSUFBSSxDQUFDLEVBQUVDLElBQUksQ0FBQztRQUN2RSxJQUFJLENBQUNDLFFBQVEsRUFBRSxPQUFPTCxHQUFHLENBQUNNLElBQUksQ0FBQ1gsb0VBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7UUFDakUsT0FBT0ssR0FBRyxDQUFDTSxJQUFJLENBQUNWLHNFQUFlLENBQUNTLFFBQVEsQ0FBQyxDQUFDLENBQUM7S0FDNUMsQ0FBQyxPQUFPRSxLQUFLLEVBQUU7UUFDZEMsT0FBTyxDQUFDQyxHQUFHLENBQUNGLEtBQUssQ0FBQyxDQUFDO1FBQ25CLE9BQU9QLEdBQUcsQ0FBQ00sSUFBSSxDQUFDWCxvRUFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztLQUNuRDtDQUNGLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9jb250cm9sbGVycy9jb2RlZ2VuLmNvbnRyb2xsZXIudHM/N2E5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSBcIm5leHRcIjtcbmltcG9ydCB7IGdldDcyMUNvbnRyYWN0Q29kZSB9IGZyb20gXCIuLi9zZXJ2aWNlcy9jb250cmFjdC5zZXJ2aWNlXCI7XG5pbXBvcnQgeyBnZXRBYmlFdm1Db2RlRnJvbVNvbGlkaXR5IH0gZnJvbSBcIi4uL3NlcnZpY2VzL3NvbGlkaXR5LnNlcnZpY2VcIjtcbmltcG9ydCB7IGVycm9yUmVzcG9uc2UsIHN1Y2Nlc3NSZXNwb25zZSB9IGZyb20gXCIuLi91dGlscy9SZXNwb25zZS51dGlsc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplU3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL1N0cmluZy51dGlsc1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0NzIxQ29tcGlsZWRDb250cmFjdCA9IGFzeW5jIChcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2VcbikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGNvbnRyYWN0TmFtZSA9IHJlcS5xdWVyeS5uYW1lO1xuICAgIGNvbnN0IG5hbWUgPVxuICAgICAgY29udHJhY3ROYW1lICYmIHR5cGVvZiBjb250cmFjdE5hbWUgPT0gXCJzdHJpbmdcIlxuICAgICAgICA/IGNvbnRyYWN0TmFtZVxuICAgICAgICA6IFwiQ29sbGVjdGlvbjcyMVwiO1xuICAgIC8vICAgY29uc29sZS5sb2coXCJuYW1lIDogXCIsIG5hbWUpO1xuICAgIC8vICAgY29uc29sZS5sb2coXCJuemQgbmFtZSA6IFwiLCBub3JtYWxpemVTdHJpbmcobmFtZSkpO1xuICAgIGNvbnN0IGNvZGUgPSBnZXQ3MjFDb250cmFjdENvZGUobmFtZSk7XG4gICAgY29uc3QgaW5pdENvZGUgPSBnZXRBYmlFdm1Db2RlRnJvbVNvbGlkaXR5KG5vcm1hbGl6ZVN0cmluZyhuYW1lKSwgY29kZSk7XG4gICAgaWYgKCFpbml0Q29kZSkgcmV0dXJuIHJlcy5qc29uKGVycm9yUmVzcG9uc2UoXCJFcnJvciBjb21waWxpbmdcIikpO1xuICAgIHJldHVybiByZXMuanNvbihzdWNjZXNzUmVzcG9uc2UoaW5pdENvZGUpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgcmV0dXJuIHJlcy5qc29uKGVycm9yUmVzcG9uc2UoXCJFcnJvciBjb21waWxpbmdcIikpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbImdldDcyMUNvbnRyYWN0Q29kZSIsImdldEFiaUV2bUNvZGVGcm9tU29saWRpdHkiLCJlcnJvclJlc3BvbnNlIiwic3VjY2Vzc1Jlc3BvbnNlIiwibm9ybWFsaXplU3RyaW5nIiwiZ2V0NzIxQ29tcGlsZWRDb250cmFjdCIsInJlcSIsInJlcyIsImNvbnRyYWN0TmFtZSIsInF1ZXJ5IiwibmFtZSIsImNvZGUiLCJpbml0Q29kZSIsImpzb24iLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./controllers/codegen.controller.ts\n");

/***/ }),

/***/ "(api)/./lib/db.ts":
/*!*******************!*\
  !*** ./lib/db.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"prisma\": () => (/* binding */ prisma)\n/* harmony export */ });\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client */ \"@prisma/client\");\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_0__);\n\nconst prisma = global.prisma || new _prisma_client__WEBPACK_IMPORTED_MODULE_0__.PrismaClient({\n    log: [\n        \"query\"\n    ]\n});\nif (true) global.prisma = prisma;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvZGIudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBUXZDLE1BQU1DLE1BQU0sR0FDakJDLE1BQU0sQ0FBQ0QsTUFBTSxJQUNiLElBQUlELHdEQUFZLENBQUM7SUFDZkcsR0FBRyxFQUFFO1FBQUMsT0FBTztLQUFDO0NBQ2YsQ0FBQyxDQUFDO0FBRUwsSUFBSUMsSUFBcUMsRUFBRUYsTUFBTSxDQUFDRCxNQUFNLEdBQUdBLE1BQU0sQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL2xpYi9kYi50cz8xZGYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByaXNtYUNsaWVudCB9IGZyb20gXCJAcHJpc21hL2NsaWVudFwiO1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGFsbG93IGdsb2JhbCBgdmFyYCBkZWNsYXJhdGlvbnNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxuICB2YXIgcHJpc21hOiBQcmlzbWFDbGllbnQgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBjb25zdCBwcmlzbWEgPVxuICBnbG9iYWwucHJpc21hIHx8XG4gIG5ldyBQcmlzbWFDbGllbnQoe1xuICAgIGxvZzogW1wicXVlcnlcIl0sXG4gIH0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSBnbG9iYWwucHJpc21hID0gcHJpc21hO1xuIl0sIm5hbWVzIjpbIlByaXNtYUNsaWVudCIsInByaXNtYSIsImdsb2JhbCIsImxvZyIsInByb2Nlc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./lib/db.ts\n");

/***/ }),

/***/ "(api)/./middlewares/user.ts":
/*!*****************************!*\
  !*** ./middlewares/user.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _services_discord_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../services/discord.service */ \"(api)/./services/discord.service.ts\");\n/* harmony import */ var _services_user_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/user.service */ \"(api)/./services/user.service.ts\");\n/* harmony import */ var _utils_Request_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Request.utils */ \"(api)/./utils/Request.utils.ts\");\n/* harmony import */ var _utils_Response_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Response.utils */ \"(api)/./utils/Response.utils.ts\");\n\n\n\n\nconst onlyValidUser = async (req, res, next)=>{\n    try {\n        const accessToken = (0,_utils_Request_utils__WEBPACK_IMPORTED_MODULE_2__.getAccessTokenFromCookie)(req);\n        if (!accessToken) return res.json((0,_utils_Response_utils__WEBPACK_IMPORTED_MODULE_3__.errorResponse)(\"Access Token not provided\"));\n        const user = await (0,_services_discord_service__WEBPACK_IMPORTED_MODULE_0__.getUserByAccessToken)(accessToken);\n        if (!user) return res.json((0,_utils_Response_utils__WEBPACK_IMPORTED_MODULE_3__.errorResponse)(\"Invalid access token\"));\n        const dbUser = await (0,_services_user_service__WEBPACK_IMPORTED_MODULE_1__.getUserByDiscordIdentifiers)(user.username, user.discriminator);\n        if (!dbUser) {\n            const cookie = (0,_utils_Request_utils__WEBPACK_IMPORTED_MODULE_2__.getHttpCookie)(req, res);\n            cookie.set(\"auth_page_message\", \"You must login to continue\");\n            return res.redirect(\"/authenticate\");\n        }\n        next();\n    } catch (error) {\n        console.log(\"Error only user middleware : \", error);\n        return res.json((0,_utils_Response_utils__WEBPACK_IMPORTED_MODULE_3__.errorResponse)(error));\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (onlyValidUser);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9taWRkbGV3YXJlcy91c2VyLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRW1FO0FBQ0k7QUFJdkM7QUFDd0I7QUFFeEQsTUFBTUssYUFBYSxHQUFHLE9BQ3BCQyxHQUFtQixFQUNuQkMsR0FBb0IsRUFDcEJDLElBQWlCLEdBQ2Q7SUFDSCxJQUFJO1FBQ0YsTUFBTUMsV0FBVyxHQUFHUCw4RUFBd0IsQ0FBQ0ksR0FBRyxDQUFDO1FBQ2pELElBQUksQ0FBQ0csV0FBVyxFQUNkLE9BQU9GLEdBQUcsQ0FBQ0csSUFBSSxDQUFDTixvRUFBYSxDQUFDLDJCQUEyQixDQUFDLENBQUMsQ0FBQztRQUM5RCxNQUFNTyxJQUFJLEdBQUcsTUFBTVgsK0VBQW9CLENBQUNTLFdBQVcsQ0FBQztRQUNwRCxJQUFJLENBQUNFLElBQUksRUFBRSxPQUFPSixHQUFHLENBQUNHLElBQUksQ0FBQ04sb0VBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7UUFDbEUsTUFBTVEsTUFBTSxHQUFHLE1BQU1YLG1GQUEyQixDQUM5Q1UsSUFBSSxDQUFDRSxRQUFRLEVBQ2JGLElBQUksQ0FBQ0csYUFBYSxDQUNuQjtRQUNELElBQUksQ0FBQ0YsTUFBTSxFQUFFO1lBQ1gsTUFBTUcsTUFBTSxHQUFHWixtRUFBYSxDQUFDRyxHQUFHLEVBQUVDLEdBQUcsQ0FBQztZQUN0Q1EsTUFBTSxDQUFDQyxHQUFHLENBQUMsbUJBQW1CLEVBQUUsNEJBQTRCLENBQUMsQ0FBQztZQUM5RCxPQUFPVCxHQUFHLENBQUNVLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQztTQUN0QztRQUNEVCxJQUFJLEVBQUUsQ0FBQztLQUNSLENBQUMsT0FBT1UsS0FBSyxFQUFFO1FBQ2RDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLCtCQUErQixFQUFFRixLQUFLLENBQUMsQ0FBQztRQUNwRCxPQUFPWCxHQUFHLENBQUNHLElBQUksQ0FBQ04sb0VBQWEsQ0FBQ2MsS0FBSyxDQUFDLENBQUMsQ0FBQztLQUN2QztDQUNGO0FBRUQsaUVBQWViLGFBQWEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL21pZGRsZXdhcmVzL3VzZXIudHM/NWQwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSBcIm5leHRcIjtcbmltcG9ydCB7IE5leHRIYW5kbGVyIH0gZnJvbSBcIm5leHQtY29ubmVjdFwiO1xuaW1wb3J0IHsgZ2V0VXNlckJ5QWNjZXNzVG9rZW4gfSBmcm9tIFwiLi4vc2VydmljZXMvZGlzY29yZC5zZXJ2aWNlXCI7XG5pbXBvcnQgeyBnZXRVc2VyQnlEaXNjb3JkSWRlbnRpZmllcnMgfSBmcm9tIFwiLi4vc2VydmljZXMvdXNlci5zZXJ2aWNlXCI7XG5pbXBvcnQge1xuICBnZXRBY2Nlc3NUb2tlbkZyb21Db29raWUsXG4gIGdldEh0dHBDb29raWUsXG59IGZyb20gXCIuLi91dGlscy9SZXF1ZXN0LnV0aWxzXCI7XG5pbXBvcnQgeyBlcnJvclJlc3BvbnNlIH0gZnJvbSBcIi4uL3V0aWxzL1Jlc3BvbnNlLnV0aWxzXCI7XG5cbmNvbnN0IG9ubHlWYWxpZFVzZXIgPSBhc3luYyAoXG4gIHJlcTogTmV4dEFwaVJlcXVlc3QsXG4gIHJlczogTmV4dEFwaVJlc3BvbnNlLFxuICBuZXh0OiBOZXh0SGFuZGxlclxuKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYWNjZXNzVG9rZW4gPSBnZXRBY2Nlc3NUb2tlbkZyb21Db29raWUocmVxKTtcbiAgICBpZiAoIWFjY2Vzc1Rva2VuKVxuICAgICAgcmV0dXJuIHJlcy5qc29uKGVycm9yUmVzcG9uc2UoXCJBY2Nlc3MgVG9rZW4gbm90IHByb3ZpZGVkXCIpKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0VXNlckJ5QWNjZXNzVG9rZW4oYWNjZXNzVG9rZW4pO1xuICAgIGlmICghdXNlcikgcmV0dXJuIHJlcy5qc29uKGVycm9yUmVzcG9uc2UoXCJJbnZhbGlkIGFjY2VzcyB0b2tlblwiKSk7XG4gICAgY29uc3QgZGJVc2VyID0gYXdhaXQgZ2V0VXNlckJ5RGlzY29yZElkZW50aWZpZXJzKFxuICAgICAgdXNlci51c2VybmFtZSxcbiAgICAgIHVzZXIuZGlzY3JpbWluYXRvclxuICAgICk7XG4gICAgaWYgKCFkYlVzZXIpIHtcbiAgICAgIGNvbnN0IGNvb2tpZSA9IGdldEh0dHBDb29raWUocmVxLCByZXMpO1xuICAgICAgY29va2llLnNldChcImF1dGhfcGFnZV9tZXNzYWdlXCIsIFwiWW91IG11c3QgbG9naW4gdG8gY29udGludWVcIik7XG4gICAgICByZXR1cm4gcmVzLnJlZGlyZWN0KFwiL2F1dGhlbnRpY2F0ZVwiKTtcbiAgICB9XG4gICAgbmV4dCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUubG9nKFwiRXJyb3Igb25seSB1c2VyIG1pZGRsZXdhcmUgOiBcIiwgZXJyb3IpO1xuICAgIHJldHVybiByZXMuanNvbihlcnJvclJlc3BvbnNlKGVycm9yKSk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IG9ubHlWYWxpZFVzZXI7XG4iXSwibmFtZXMiOlsiZ2V0VXNlckJ5QWNjZXNzVG9rZW4iLCJnZXRVc2VyQnlEaXNjb3JkSWRlbnRpZmllcnMiLCJnZXRBY2Nlc3NUb2tlbkZyb21Db29raWUiLCJnZXRIdHRwQ29va2llIiwiZXJyb3JSZXNwb25zZSIsIm9ubHlWYWxpZFVzZXIiLCJyZXEiLCJyZXMiLCJuZXh0IiwiYWNjZXNzVG9rZW4iLCJqc29uIiwidXNlciIsImRiVXNlciIsInVzZXJuYW1lIiwiZGlzY3JpbWluYXRvciIsImNvb2tpZSIsInNldCIsInJlZGlyZWN0IiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./middlewares/user.ts\n");

/***/ }),

/***/ "(api)/./pages/api/v1/contract/collection721.ts":
/*!************************************************!*\
  !*** ./pages/api/v1/contract/collection721.ts ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var next_connect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next-connect */ \"next-connect\");\n/* harmony import */ var _controllers_codegen_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../controllers/codegen.controller */ \"(api)/./controllers/codegen.controller.ts\");\n/* harmony import */ var _middlewares_user__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../middlewares/user */ \"(api)/./middlewares/user.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([next_connect__WEBPACK_IMPORTED_MODULE_0__]);\nnext_connect__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_connect__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().use(_middlewares_user__WEBPACK_IMPORTED_MODULE_2__[\"default\"]).get(_controllers_codegen_controller__WEBPACK_IMPORTED_MODULE_1__.get721CompiledContract));\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvdjEvY29udHJhY3QvY29sbGVjdGlvbjcyMS50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ3VDO0FBQzZDO0FBQzNCO0FBRXpELGlFQUFlQSx3REFBVyxFQUFtQyxDQUMxREcsR0FBRyxDQUFDRCx5REFBYSxDQUFDLENBQ2xCRSxHQUFHLENBQUNILG1GQUFzQixDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9wYWdlcy9hcGkvdjEvY29udHJhY3QvY29sbGVjdGlvbjcyMS50cz8xNzIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRBcGlSZXF1ZXN0LCBOZXh0QXBpUmVzcG9uc2UgfSBmcm9tIFwibmV4dFwiO1xuaW1wb3J0IG5leHRDb25uZWN0IGZyb20gXCJuZXh0LWNvbm5lY3RcIjtcbmltcG9ydCB7IGdldDcyMUNvbXBpbGVkQ29udHJhY3QgfSBmcm9tIFwiLi4vLi4vLi4vLi4vY29udHJvbGxlcnMvY29kZWdlbi5jb250cm9sbGVyXCI7XG5pbXBvcnQgb25seVZhbGlkVXNlciBmcm9tIFwiLi4vLi4vLi4vLi4vbWlkZGxld2FyZXMvdXNlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBuZXh0Q29ubmVjdDxOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlPigpXG4gIC51c2Uob25seVZhbGlkVXNlcilcbiAgLmdldChnZXQ3MjFDb21waWxlZENvbnRyYWN0KTtcbiJdLCJuYW1lcyI6WyJuZXh0Q29ubmVjdCIsImdldDcyMUNvbXBpbGVkQ29udHJhY3QiLCJvbmx5VmFsaWRVc2VyIiwidXNlIiwiZ2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./pages/api/v1/contract/collection721.ts\n");

/***/ }),

/***/ "(api)/./services/contract.service.ts":
/*!**************************************!*\
  !*** ./services/contract.service.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"get721ContractCode\": () => (/* binding */ get721ContractCode)\n/* harmony export */ });\n/* harmony import */ var _utils_String_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/String.utils */ \"(api)/./utils/String.utils.ts\");\n\nconst get721ContractCode = (contractName)=>{\n    return `\n    // SPDX-License-Identifier: MIT\n\n// Sources flattened with hardhat v2.9.9 https://hardhat.org\n\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.6.0\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * 'interfaceId'. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v4.6.0\n\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when 'tokenId' token is transferred from 'from' to 'to'.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when 'owner' enables 'approved' to manage the 'tokenId' token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when 'owner' enables or disables ('approved') 'operator' to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ''owner'''s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the 'tokenId' token.\n     *\n     * Requirements:\n     *\n     * - 'tokenId' must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers 'tokenId' token from 'from' to 'to'.\n     *\n     * Requirements:\n     *\n     * - 'from' cannot be the zero address.\n     * - 'to' cannot be the zero address.\n     * - 'tokenId' token must exist and be owned by 'from'.\n     * - If the caller is not 'from', it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If 'to' refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers 'tokenId' token from 'from' to 'to', checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - 'from' cannot be the zero address.\n     * - 'to' cannot be the zero address.\n     * - 'tokenId' token must exist and be owned by 'from'.\n     * - If the caller is not 'from', it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If 'to' refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers 'tokenId' token from 'from' to 'to'.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - 'from' cannot be the zero address.\n     * - 'to' cannot be the zero address.\n     * - 'tokenId' token must be owned by 'from'.\n     * - If the caller is not 'from', it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to 'to' to transfer 'tokenId' token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - 'tokenId' must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove 'operator' as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The 'operator' cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for 'tokenId' token.\n     *\n     * Requirements:\n     *\n     * - 'tokenId' must exist.\n     */\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    /**\n     * @dev Returns if the 'operator' is allowed to manage all of the assets of 'owner'.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n}\n\n// File @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol@v4.6.0\n\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} 'tokenId' token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by 'operator' from 'from', this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with 'IERC721Receiver.onERC721Received.selector'.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n// File @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol@v4.6.0\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for 'tokenId' token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// File @openzeppelin/contracts/utils/Address.sol@v4.6.0\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if 'account' is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, 'isContract' will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on 'isContract' to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's 'transfer': sends 'amount' wei to\n     * 'recipient', forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by 'transfer', making them unable to receive funds via\n     * 'transfer'. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to 'recipient', care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level 'call'. A\n     * plain 'call' is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If 'target' reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions['abi.decode'].\n     *\n     * Requirements:\n     *\n     * - 'target' must be a contract.\n     * - calling 'target' with 'data' must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}['functionCall'], but with\n     * 'errorMessage' as a fallback revert reason when 'target' reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}['functionCall'],\n     * but also transferring 'value' wei to 'target'.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least 'value'.\n     * - the called Solidity function must be 'payable'.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}['functionCallWithValue'], but\n     * with 'errorMessage' as a fallback revert reason when 'target' reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}['functionCall'],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}['functionCall'],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}['functionCall'],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}['functionCall'],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File @openzeppelin/contracts/utils/Context.sol@v4.6.0\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// File @openzeppelin/contracts/utils/Strings.sol@v4.6.0\n\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a 'uint256' to its ASCII 'string' decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a 'uint256' to its ASCII 'string' hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a 'uint256' to its ASCII 'string' hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.6.0\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * '''solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * '''\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// File @openzeppelin/contracts/token/ERC721/ERC721.sol@v4.6.0\n\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a 'name' and a 'symbol' to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        require(\n            owner != address(0),\n            \"ERC721: balance query for the zero address\"\n        );\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        address owner = _owners[tokenId];\n        require(\n            owner != address(0),\n            \"ERC721: owner query for nonexistent token\"\n        );\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        string memory baseURI = _baseURI();\n        return\n            bytes(baseURI).length > 0\n                ? string(abi.encodePacked(baseURI, tokenId.toString()))\n                : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the 'baseURI' and the 'tokenId'. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (address)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: approved query for nonexistent token\"\n        );\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers 'tokenId' token from 'from' to 'to', checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * '_data' is additional data, it has no specified format and it is sent in call to 'to'.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - 'from' cannot be the zero address.\n     * - 'to' cannot be the zero address.\n     * - 'tokenId' token must exist and be owned by 'from'.\n     * - If 'to' refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Returns whether 'tokenId' exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted ('_mint'),\n     * and stop existing when they are burned ('_burn').\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether 'spender' is allowed to manage 'tokenId'.\n     *\n     * Requirements:\n     *\n     * - 'tokenId' must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721: operator query for nonexistent token\"\n        );\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner ||\n            isApprovedForAll(owner, spender) ||\n            getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints 'tokenId' and transfers it to 'to'.\n     *\n     * Requirements:\n     *\n     * - 'tokenId' must not exist.\n     * - If 'to' refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}['_safeMint'], with an additional 'data' parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints 'tokenId' and transfers it to 'to'.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - 'tokenId' must not exist.\n     * - 'to' cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys 'tokenId'.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - 'tokenId' must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers 'tokenId' from 'from' to 'to'.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - 'to' cannot be the zero address.\n     * - 'tokenId' token must be owned by 'from'.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(\n            ERC721.ownerOf(tokenId) == from,\n            \"ERC721: transfer from incorrect owner\"\n        );\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve 'to' to operate on 'tokenId'\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve 'operator' to operate on all of 'owner' tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    _msgSender(),\n                    from,\n                    tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"ERC721: transfer to non ERC721Receiver implementer\"\n                    );\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When 'from' and 'to' are both non-zero, ''from'''s 'tokenId' will be\n     * transferred to 'to'.\n     * - When 'from' is zero, 'tokenId' will be minted for 'to'.\n     * - When 'to' is zero, ''from'''s 'tokenId' will be burned.\n     * - 'from' and 'to' are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when 'from' and 'to' are both non-zero.\n     * - 'from' and 'to' are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n// File @openzeppelin/contracts/access/Ownable.sol@v4.6.0\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * 'onlyOwner', which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * 'onlyOwner' functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account ('newOwner').\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account ('newOwner').\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// File @openzeppelin/contracts/utils/cryptography/MerkleProof.sol@v4.6.0\n\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See 'test/utils/cryptography/MerkleProof.test.js' for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a 'leaf' can be proved to be a part of a Merkle tree\n     * defined by 'root'. For this, a 'proof' must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from 'leaf' using 'proof'. A 'proof' is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b)\n        private\n        pure\n        returns (bytes32 value)\n    {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n\n// File @openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol@v4.6.0\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721URIStorage: URI query for nonexistent token\"\n        );\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets '_tokenURI' as the tokenURI of 'tokenId'.\n     *\n     * Requirements:\n     *\n     * - 'tokenId' must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI)\n        internal\n        virtual\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721URIStorage: URI set of nonexistent token\"\n        );\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys 'tokenId'.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - 'tokenId' must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n\n// File @openzeppelin/contracts/utils/Counters.sol@v4.6.0\n\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with 'using Counters for Counters.Counter;'\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n\n// File @openzeppelin/contracts/utils/cryptography/ECDSA.sol@v4.6.0\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message ('hash') with\n     * 'signature' or error string. This address can then be used for verification purposes.\n     *\n     * The 'ecrecover' EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the 's' value to be in the lower\n     * half order, and the 'v' value to be either 27 or 28.\n     *\n     * IMPORTANT: 'hash' _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address, RecoverError)\n    {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message ('hash') with\n     * 'signature'. This address can then be used for verification purposes.\n     *\n     * The 'ecrecover' EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the 's' value to be in the lower\n     * half order, and the 'v' value to be either 27 or 28.\n     *\n     * IMPORTANT: 'hash' _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address)\n    {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the 'r' and 'vs' short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs &\n            bytes32(\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n            );\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the 'r and 'vs' short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the 'v',\n     * 'r' and 's' signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the 'v',\n     * 'r' and 's' signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a 'hash'. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign['eth_sign']\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return\n            keccak256(\n                abi.encodePacked(\"\\\\x19Ethereum Signed Message:\\\\n32\", hash)\n            );\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from 's'. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign['eth_sign']\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"\\\\x19Ethereum Signed Message:\\\\n\",\n                    Strings.toString(s.length),\n                    s\n                )\n            );\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * 'domainSeparator' and a 'structHash'. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712['eth_signTypedData']\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\\\x19\\\\x01\", domainSeparator, structHash)\n            );\n    }\n}\n\n\npragma solidity ^0.8.0;\n\ncontract ${(0,_utils_String_utils__WEBPACK_IMPORTED_MODULE_0__.normalizeString)(contractName)} is Ownable, ERC721URIStorage {\n        using Counters for Counters.Counter;\n        Counters.Counter private nextTokenId;\n        using ECDSA for bytes32;\n        struct SaleConfig {\n            bool status;\n            uint256 startTime;\n            uint256 endTime;\n        }\n    \n        uint256 public privateMintCharge;\n        uint256 public publicMintCharge;\n    \n        bytes32 public whitelistRoot;\n    \n        address public feeDestination;\n    \n        SaleConfig public privateSale1;\n        SaleConfig public privateSale2;\n        SaleConfig public publicSale;\n    \n        uint256 public maxMintInPrivate;\n        uint256 public maxMintInPublic;\n    \n        mapping(bytes => bool) public isSignatureRedeemed;\n    \n        event Mint(address msgSender, string tokenUri, uint256 tokenId);\n    \n        constructor(\n            address _feeDestination,\n            bytes32 _whitelistRoot,\n            uint256 _privateMintCharge,\n            uint256 _publicMintCharge,\n            string memory _name,\n            string memory _symbol\n        ) ERC721(_name, _symbol) {\n            feeDestination = _feeDestination;\n            whitelistRoot = _whitelistRoot;\n            privateMintCharge = _privateMintCharge;\n            publicMintCharge = _publicMintCharge;\n        }\n    \n        function updateMaxMintInPrivate(uint256 _maxMintInPrivate)\n            public\n            onlyOwner\n        {\n            maxMintInPrivate = _maxMintInPrivate;\n        }\n    \n        function updateMaxMintInPublic(uint256 _maxMintInPublic) public onlyOwner {\n            maxMintInPublic = _maxMintInPublic;\n        }\n    \n        function updatePrivateMintCharge(uint256 charge) public onlyOwner {\n            privateMintCharge = charge;\n        }\n    \n        function updatePublicMintCharge(uint256 charge) public onlyOwner {\n            publicMintCharge = charge;\n        }\n    \n        function updatePrivateSale1(\n            uint256 _startTime,\n            uint256 _endTime,\n            bool _status\n        ) public onlyOwner {\n            privateSale1.startTime = _startTime;\n            privateSale1.endTime = _endTime;\n            privateSale1.status = _status;\n        }\n    \n        function updatePrivateSale2(\n            uint256 _startTime,\n            uint256 _endTime,\n            bool _status\n        ) public onlyOwner {\n            privateSale2.startTime = _startTime;\n            privateSale2.endTime = _endTime;\n            privateSale2.status = _status;\n        }\n    \n        function updatePublicSale(\n            uint256 _startTime,\n            uint256 _endTime,\n            bool _status\n        ) public onlyOwner {\n            publicSale.startTime = _startTime;\n            publicSale.endTime = _endTime;\n            publicSale.status = _status;\n        }\n    \n        function updateWhitelist(bytes32 _root) public onlyOwner {\n            whitelistRoot = _root;\n        }\n    \n        function updateFeeToAddress(address _feeDestination) public onlyOwner {\n            feeDestination = _feeDestination;\n        }\n    \n        function updateTokenUri(uint256 tokenId, string memory _tokenURI)\n            public\n            onlyOwner\n        {\n            _setTokenURI(tokenId, _tokenURI);\n        }\n    \n        modifier privateFeeProvided() {\n            require(msg.value >= privateMintCharge, \"Fee not provided\");\n            payable(feeDestination).transfer(msg.value);\n            _;\n        }\n    \n        modifier publicFeeProvided() {\n            require(msg.value >= publicMintCharge, \"Fee not provided\");\n            payable(feeDestination).transfer(msg.value);\n            _;\n        }\n    \n        modifier onlyWhitelisted(bytes32[] memory proof) {\n            require(\n                MerkleProof.verify(\n                    proof,\n                    whitelistRoot,\n                    keccak256(abi.encodePacked(msg.sender))\n                ),\n                \"Not whitelisted\"\n            );\n            _;\n        }\n    \n        modifier onlyPrivateSale() {\n            uint256 time = block.timestamp;\n            require(\n                (privateSale1.status &&\n                    time > privateSale1.startTime &&\n                    (privateSale1.endTime > time || privateSale1.endTime == 0)) ||\n                    (privateSale2.status &&\n                        time > privateSale2.startTime &&\n                        (privateSale2.endTime > time || privateSale2.endTime == 0)),\n                \"Not a private sale\"\n            );\n            _;\n        }\n    \n        modifier onlyPublicSale() {\n            uint256 time = block.timestamp;\n            require(\n                publicSale.status &&\n                    time > publicSale.startTime &&\n                    (publicSale.endTime > time || publicSale.endTime == 0),\n                \"Not a public sale\"\n            );\n            _;\n        }\n    \n        modifier onlyValidTokenUri(\n            string memory _tokenURI,\n            bytes memory signature\n        ) {\n            require(!isSignatureRedeemed[signature], \"Signature already redeemed\");\n            require(\n                keccak256(abi.encodePacked(_tokenURI))\n                    .toEthSignedMessageHash()\n                    .recover(signature) == owner(),\n                \"Invalid token URI\"\n            );\n            _;\n        }\n    \n        modifier maxPrivateLimitNotReached() {\n            if (maxMintInPrivate != 0) {\n                require(\n                    balanceOf(msg.sender) < maxMintInPrivate,\n                    \"Max limit reached\"\n                );\n            }\n            _;\n        }\n    \n        modifier maxPublicLimitNotReached() {\n            if (maxMintInPublic != 0) {\n                require(\n                    balanceOf(msg.sender) < maxMintInPublic,\n                    \"Max limit reached\"\n                );\n            }\n            _;\n        }\n    \n        function mintPrivate(\n            string memory _tokenURI,\n            bytes32[] memory proof,\n            bytes memory signature\n        )\n            public\n            payable\n            onlyPrivateSale\n            maxPrivateLimitNotReached\n            onlyWhitelisted(proof)\n            onlyValidTokenUri(_tokenURI, signature)\n            privateFeeProvided\n        {\n            _mint(msg.sender, nextTokenId.current());\n            _setTokenURI(nextTokenId.current(), _tokenURI);\n            isSignatureRedeemed[signature] = true;\n            emit Mint(msg.sender, _tokenURI, nextTokenId.current());\n            nextTokenId.increment();\n        }\n    \n        function mint(string memory _tokenURI, bytes memory signature)\n            public\n            payable\n            onlyPublicSale\n            maxPublicLimitNotReached\n            onlyValidTokenUri(_tokenURI, signature)\n            publicFeeProvided\n        {\n            _mint(msg.sender, nextTokenId.current());\n            _setTokenURI(nextTokenId.current(), _tokenURI);\n            isSignatureRedeemed[signature] = true;\n            emit Mint(msg.sender, _tokenURI, nextTokenId.current());\n            nextTokenId.increment();\n        }\n    }\n    \n\n    `;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zZXJ2aWNlcy9jb250cmFjdC5zZXJ2aWNlLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdEO0FBRWpELE1BQU1DLGtCQUFrQixHQUFHLENBQUNDLFlBQW9CLEdBQUs7SUFDMUQsT0FBTyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQStyREQsRUFBRUYsb0VBQWUsQ0FBQ0UsWUFBWSxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFrT3JDLENBQUMsQ0FBQztDQUNMLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9zZXJ2aWNlcy9jb250cmFjdC5zZXJ2aWNlLnRzPzY3NjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbm9ybWFsaXplU3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL1N0cmluZy51dGlsc1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0NzIxQ29udHJhY3RDb2RlID0gKGNvbnRyYWN0TmFtZTogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBgXG4gICAgLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuXG4vLyBTb3VyY2VzIGZsYXR0ZW5lZCB3aXRoIGhhcmRoYXQgdjIuOS45IGh0dHBzOi8vaGFyZGhhdC5vcmdcblxuLy8gRmlsZSBAb3BlbnplcHBlbGluL2NvbnRyYWN0cy91dGlscy9pbnRyb3NwZWN0aW9uL0lFUkMxNjUuc29sQHY0LjYuMFxuXG4vLyBPcGVuWmVwcGVsaW4gQ29udHJhY3RzIHY0LjQuMSAodXRpbHMvaW50cm9zcGVjdGlvbi9JRVJDMTY1LnNvbClcblxucHJhZ21hIHNvbGlkaXR5IF4wLjguMDtcblxuLyoqXG4gKiBAZGV2IEludGVyZmFjZSBvZiB0aGUgRVJDMTY1IHN0YW5kYXJkLCBhcyBkZWZpbmVkIGluIHRoZVxuICogaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xNjVbRUlQXS5cbiAqXG4gKiBJbXBsZW1lbnRlcnMgY2FuIGRlY2xhcmUgc3VwcG9ydCBvZiBjb250cmFjdCBpbnRlcmZhY2VzLCB3aGljaCBjYW4gdGhlbiBiZVxuICogcXVlcmllZCBieSBvdGhlcnMgKHtFUkMxNjVDaGVja2VyfSkuXG4gKlxuICogRm9yIGFuIGltcGxlbWVudGF0aW9uLCBzZWUge0VSQzE2NX0uXG4gKi9cbmludGVyZmFjZSBJRVJDMTY1IHtcbiAgICAvKipcbiAgICAgKiBAZGV2IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbnRyYWN0IGltcGxlbWVudHMgdGhlIGludGVyZmFjZSBkZWZpbmVkIGJ5XG4gICAgICogJ2ludGVyZmFjZUlkJy4gU2VlIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xNjUjaG93LWludGVyZmFjZXMtYXJlLWlkZW50aWZpZWRbRUlQIHNlY3Rpb25dXG4gICAgICogdG8gbGVhcm4gbW9yZSBhYm91dCBob3cgdGhlc2UgaWRzIGFyZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYWxsIG11c3QgdXNlIGxlc3MgdGhhbiAzMCAwMDAgZ2FzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1cHBvcnRzSW50ZXJmYWNlKGJ5dGVzNCBpbnRlcmZhY2VJZCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChib29sKTtcbn1cblxuLy8gRmlsZSBAb3BlbnplcHBlbGluL2NvbnRyYWN0cy90b2tlbi9FUkM3MjEvSUVSQzcyMS5zb2xAdjQuNi4wXG5cbi8vIE9wZW5aZXBwZWxpbiBDb250cmFjdHMgKGxhc3QgdXBkYXRlZCB2NC42LjApICh0b2tlbi9FUkM3MjEvSUVSQzcyMS5zb2wpXG5cbnByYWdtYSBzb2xpZGl0eSBeMC44LjA7XG5cbi8qKlxuICogQGRldiBSZXF1aXJlZCBpbnRlcmZhY2Ugb2YgYW4gRVJDNzIxIGNvbXBsaWFudCBjb250cmFjdC5cbiAqL1xuaW50ZXJmYWNlIElFUkM3MjEgaXMgSUVSQzE2NSB7XG4gICAgLyoqXG4gICAgICogQGRldiBFbWl0dGVkIHdoZW4gJ3Rva2VuSWQnIHRva2VuIGlzIHRyYW5zZmVycmVkIGZyb20gJ2Zyb20nIHRvICd0bycuXG4gICAgICovXG4gICAgZXZlbnQgVHJhbnNmZXIoXG4gICAgICAgIGFkZHJlc3MgaW5kZXhlZCBmcm9tLFxuICAgICAgICBhZGRyZXNzIGluZGV4ZWQgdG8sXG4gICAgICAgIHVpbnQyNTYgaW5kZXhlZCB0b2tlbklkXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBkZXYgRW1pdHRlZCB3aGVuICdvd25lcicgZW5hYmxlcyAnYXBwcm92ZWQnIHRvIG1hbmFnZSB0aGUgJ3Rva2VuSWQnIHRva2VuLlxuICAgICAqL1xuICAgIGV2ZW50IEFwcHJvdmFsKFxuICAgICAgICBhZGRyZXNzIGluZGV4ZWQgb3duZXIsXG4gICAgICAgIGFkZHJlc3MgaW5kZXhlZCBhcHByb3ZlZCxcbiAgICAgICAgdWludDI1NiBpbmRleGVkIHRva2VuSWRcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQGRldiBFbWl0dGVkIHdoZW4gJ293bmVyJyBlbmFibGVzIG9yIGRpc2FibGVzICgnYXBwcm92ZWQnKSAnb3BlcmF0b3InIHRvIG1hbmFnZSBhbGwgb2YgaXRzIGFzc2V0cy5cbiAgICAgKi9cbiAgICBldmVudCBBcHByb3ZhbEZvckFsbChcbiAgICAgICAgYWRkcmVzcyBpbmRleGVkIG93bmVyLFxuICAgICAgICBhZGRyZXNzIGluZGV4ZWQgb3BlcmF0b3IsXG4gICAgICAgIGJvb2wgYXBwcm92ZWRcbiAgICApO1xuXG4gICAgLyoqXG4gICAgICogQGRldiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluICcnb3duZXInJydzIGFjY291bnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3Mgb3duZXIpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDI1NiBiYWxhbmNlKTtcblxuICAgIC8qKlxuICAgICAqIEBkZXYgUmV0dXJucyB0aGUgb3duZXIgb2YgdGhlICd0b2tlbklkJyB0b2tlbi5cbiAgICAgKlxuICAgICAqIFJlcXVpcmVtZW50czpcbiAgICAgKlxuICAgICAqIC0gJ3Rva2VuSWQnIG11c3QgZXhpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3duZXJPZih1aW50MjU2IHRva2VuSWQpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYWRkcmVzcyBvd25lcik7XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFNhZmVseSB0cmFuc2ZlcnMgJ3Rva2VuSWQnIHRva2VuIGZyb20gJ2Zyb20nIHRvICd0bycuXG4gICAgICpcbiAgICAgKiBSZXF1aXJlbWVudHM6XG4gICAgICpcbiAgICAgKiAtICdmcm9tJyBjYW5ub3QgYmUgdGhlIHplcm8gYWRkcmVzcy5cbiAgICAgKiAtICd0bycgY2Fubm90IGJlIHRoZSB6ZXJvIGFkZHJlc3MuXG4gICAgICogLSAndG9rZW5JZCcgdG9rZW4gbXVzdCBleGlzdCBhbmQgYmUgb3duZWQgYnkgJ2Zyb20nLlxuICAgICAqIC0gSWYgdGhlIGNhbGxlciBpcyBub3QgJ2Zyb20nLCBpdCBtdXN0IGJlIGFwcHJvdmVkIHRvIG1vdmUgdGhpcyB0b2tlbiBieSBlaXRoZXIge2FwcHJvdmV9IG9yIHtzZXRBcHByb3ZhbEZvckFsbH0uXG4gICAgICogLSBJZiAndG8nIHJlZmVycyB0byBhIHNtYXJ0IGNvbnRyYWN0LCBpdCBtdXN0IGltcGxlbWVudCB7SUVSQzcyMVJlY2VpdmVyLW9uRVJDNzIxUmVjZWl2ZWR9LCB3aGljaCBpcyBjYWxsZWQgdXBvbiBhIHNhZmUgdHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBFbWl0cyBhIHtUcmFuc2Zlcn0gZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FmZVRyYW5zZmVyRnJvbShcbiAgICAgICAgYWRkcmVzcyBmcm9tLFxuICAgICAgICBhZGRyZXNzIHRvLFxuICAgICAgICB1aW50MjU2IHRva2VuSWQsXG4gICAgICAgIGJ5dGVzIGNhbGxkYXRhIGRhdGFcbiAgICApIGV4dGVybmFsO1xuXG4gICAgLyoqXG4gICAgICogQGRldiBTYWZlbHkgdHJhbnNmZXJzICd0b2tlbklkJyB0b2tlbiBmcm9tICdmcm9tJyB0byAndG8nLCBjaGVja2luZyBmaXJzdCB0aGF0IGNvbnRyYWN0IHJlY2lwaWVudHNcbiAgICAgKiBhcmUgYXdhcmUgb2YgdGhlIEVSQzcyMSBwcm90b2NvbCB0byBwcmV2ZW50IHRva2VucyBmcm9tIGJlaW5nIGZvcmV2ZXIgbG9ja2VkLlxuICAgICAqXG4gICAgICogUmVxdWlyZW1lbnRzOlxuICAgICAqXG4gICAgICogLSAnZnJvbScgY2Fubm90IGJlIHRoZSB6ZXJvIGFkZHJlc3MuXG4gICAgICogLSAndG8nIGNhbm5vdCBiZSB0aGUgemVybyBhZGRyZXNzLlxuICAgICAqIC0gJ3Rva2VuSWQnIHRva2VuIG11c3QgZXhpc3QgYW5kIGJlIG93bmVkIGJ5ICdmcm9tJy5cbiAgICAgKiAtIElmIHRoZSBjYWxsZXIgaXMgbm90ICdmcm9tJywgaXQgbXVzdCBiZSBoYXZlIGJlZW4gYWxsb3dlZCB0byBtb3ZlIHRoaXMgdG9rZW4gYnkgZWl0aGVyIHthcHByb3ZlfSBvciB7c2V0QXBwcm92YWxGb3JBbGx9LlxuICAgICAqIC0gSWYgJ3RvJyByZWZlcnMgdG8gYSBzbWFydCBjb250cmFjdCwgaXQgbXVzdCBpbXBsZW1lbnQge0lFUkM3MjFSZWNlaXZlci1vbkVSQzcyMVJlY2VpdmVkfSwgd2hpY2ggaXMgY2FsbGVkIHVwb24gYSBzYWZlIHRyYW5zZmVyLlxuICAgICAqXG4gICAgICogRW1pdHMgYSB7VHJhbnNmZXJ9IGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVUcmFuc2ZlckZyb20oXG4gICAgICAgIGFkZHJlc3MgZnJvbSxcbiAgICAgICAgYWRkcmVzcyB0byxcbiAgICAgICAgdWludDI1NiB0b2tlbklkXG4gICAgKSBleHRlcm5hbDtcblxuICAgIC8qKlxuICAgICAqIEBkZXYgVHJhbnNmZXJzICd0b2tlbklkJyB0b2tlbiBmcm9tICdmcm9tJyB0byAndG8nLlxuICAgICAqXG4gICAgICogV0FSTklORzogVXNhZ2Ugb2YgdGhpcyBtZXRob2QgaXMgZGlzY291cmFnZWQsIHVzZSB7c2FmZVRyYW5zZmVyRnJvbX0gd2hlbmV2ZXIgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBSZXF1aXJlbWVudHM6XG4gICAgICpcbiAgICAgKiAtICdmcm9tJyBjYW5ub3QgYmUgdGhlIHplcm8gYWRkcmVzcy5cbiAgICAgKiAtICd0bycgY2Fubm90IGJlIHRoZSB6ZXJvIGFkZHJlc3MuXG4gICAgICogLSAndG9rZW5JZCcgdG9rZW4gbXVzdCBiZSBvd25lZCBieSAnZnJvbScuXG4gICAgICogLSBJZiB0aGUgY2FsbGVyIGlzIG5vdCAnZnJvbScsIGl0IG11c3QgYmUgYXBwcm92ZWQgdG8gbW92ZSB0aGlzIHRva2VuIGJ5IGVpdGhlciB7YXBwcm92ZX0gb3Ige3NldEFwcHJvdmFsRm9yQWxsfS5cbiAgICAgKlxuICAgICAqIEVtaXRzIGEge1RyYW5zZmVyfSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2ZlckZyb20oXG4gICAgICAgIGFkZHJlc3MgZnJvbSxcbiAgICAgICAgYWRkcmVzcyB0byxcbiAgICAgICAgdWludDI1NiB0b2tlbklkXG4gICAgKSBleHRlcm5hbDtcblxuICAgIC8qKlxuICAgICAqIEBkZXYgR2l2ZXMgcGVybWlzc2lvbiB0byAndG8nIHRvIHRyYW5zZmVyICd0b2tlbklkJyB0b2tlbiB0byBhbm90aGVyIGFjY291bnQuXG4gICAgICogVGhlIGFwcHJvdmFsIGlzIGNsZWFyZWQgd2hlbiB0aGUgdG9rZW4gaXMgdHJhbnNmZXJyZWQuXG4gICAgICpcbiAgICAgKiBPbmx5IGEgc2luZ2xlIGFjY291bnQgY2FuIGJlIGFwcHJvdmVkIGF0IGEgdGltZSwgc28gYXBwcm92aW5nIHRoZSB6ZXJvIGFkZHJlc3MgY2xlYXJzIHByZXZpb3VzIGFwcHJvdmFscy5cbiAgICAgKlxuICAgICAqIFJlcXVpcmVtZW50czpcbiAgICAgKlxuICAgICAqIC0gVGhlIGNhbGxlciBtdXN0IG93biB0aGUgdG9rZW4gb3IgYmUgYW4gYXBwcm92ZWQgb3BlcmF0b3IuXG4gICAgICogLSAndG9rZW5JZCcgbXVzdCBleGlzdC5cbiAgICAgKlxuICAgICAqIEVtaXRzIGFuIHtBcHByb3ZhbH0gZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwcm92ZShhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpIGV4dGVybmFsO1xuXG4gICAgLyoqXG4gICAgICogQGRldiBBcHByb3ZlIG9yIHJlbW92ZSAnb3BlcmF0b3InIGFzIGFuIG9wZXJhdG9yIGZvciB0aGUgY2FsbGVyLlxuICAgICAqIE9wZXJhdG9ycyBjYW4gY2FsbCB7dHJhbnNmZXJGcm9tfSBvciB7c2FmZVRyYW5zZmVyRnJvbX0gZm9yIGFueSB0b2tlbiBvd25lZCBieSB0aGUgY2FsbGVyLlxuICAgICAqXG4gICAgICogUmVxdWlyZW1lbnRzOlxuICAgICAqXG4gICAgICogLSBUaGUgJ29wZXJhdG9yJyBjYW5ub3QgYmUgdGhlIGNhbGxlci5cbiAgICAgKlxuICAgICAqIEVtaXRzIGFuIHtBcHByb3ZhbEZvckFsbH0gZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QXBwcm92YWxGb3JBbGwoYWRkcmVzcyBvcGVyYXRvciwgYm9vbCBfYXBwcm92ZWQpIGV4dGVybmFsO1xuXG4gICAgLyoqXG4gICAgICogQGRldiBSZXR1cm5zIHRoZSBhY2NvdW50IGFwcHJvdmVkIGZvciAndG9rZW5JZCcgdG9rZW4uXG4gICAgICpcbiAgICAgKiBSZXF1aXJlbWVudHM6XG4gICAgICpcbiAgICAgKiAtICd0b2tlbklkJyBtdXN0IGV4aXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFwcHJvdmVkKHVpbnQyNTYgdG9rZW5JZClcbiAgICAgICAgZXh0ZXJuYWxcbiAgICAgICAgdmlld1xuICAgICAgICByZXR1cm5zIChhZGRyZXNzIG9wZXJhdG9yKTtcblxuICAgIC8qKlxuICAgICAqIEBkZXYgUmV0dXJucyBpZiB0aGUgJ29wZXJhdG9yJyBpcyBhbGxvd2VkIHRvIG1hbmFnZSBhbGwgb2YgdGhlIGFzc2V0cyBvZiAnb3duZXInLlxuICAgICAqXG4gICAgICogU2VlIHtzZXRBcHByb3ZhbEZvckFsbH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FwcHJvdmVkRm9yQWxsKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3Mgb3BlcmF0b3IpXG4gICAgICAgIGV4dGVybmFsXG4gICAgICAgIHZpZXdcbiAgICAgICAgcmV0dXJucyAoYm9vbCk7XG59XG5cbi8vIEZpbGUgQG9wZW56ZXBwZWxpbi9jb250cmFjdHMvdG9rZW4vRVJDNzIxL0lFUkM3MjFSZWNlaXZlci5zb2xAdjQuNi4wXG5cbi8vIE9wZW5aZXBwZWxpbiBDb250cmFjdHMgKGxhc3QgdXBkYXRlZCB2NC42LjApICh0b2tlbi9FUkM3MjEvSUVSQzcyMVJlY2VpdmVyLnNvbClcblxucHJhZ21hIHNvbGlkaXR5IF4wLjguMDtcblxuLyoqXG4gKiBAdGl0bGUgRVJDNzIxIHRva2VuIHJlY2VpdmVyIGludGVyZmFjZVxuICogQGRldiBJbnRlcmZhY2UgZm9yIGFueSBjb250cmFjdCB0aGF0IHdhbnRzIHRvIHN1cHBvcnQgc2FmZVRyYW5zZmVyc1xuICogZnJvbSBFUkM3MjEgYXNzZXQgY29udHJhY3RzLlxuICovXG5pbnRlcmZhY2UgSUVSQzcyMVJlY2VpdmVyIHtcbiAgICAvKipcbiAgICAgKiBAZGV2IFdoZW5ldmVyIGFuIHtJRVJDNzIxfSAndG9rZW5JZCcgdG9rZW4gaXMgdHJhbnNmZXJyZWQgdG8gdGhpcyBjb250cmFjdCB2aWEge0lFUkM3MjEtc2FmZVRyYW5zZmVyRnJvbX1cbiAgICAgKiBieSAnb3BlcmF0b3InIGZyb20gJ2Zyb20nLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEl0IG11c3QgcmV0dXJuIGl0cyBTb2xpZGl0eSBzZWxlY3RvciB0byBjb25maXJtIHRoZSB0b2tlbiB0cmFuc2Zlci5cbiAgICAgKiBJZiBhbnkgb3RoZXIgdmFsdWUgaXMgcmV0dXJuZWQgb3IgdGhlIGludGVyZmFjZSBpcyBub3QgaW1wbGVtZW50ZWQgYnkgdGhlIHJlY2lwaWVudCwgdGhlIHRyYW5zZmVyIHdpbGwgYmUgcmV2ZXJ0ZWQuXG4gICAgICpcbiAgICAgKiBUaGUgc2VsZWN0b3IgY2FuIGJlIG9idGFpbmVkIGluIFNvbGlkaXR5IHdpdGggJ0lFUkM3MjFSZWNlaXZlci5vbkVSQzcyMVJlY2VpdmVkLnNlbGVjdG9yJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkVSQzcyMVJlY2VpdmVkKFxuICAgICAgICBhZGRyZXNzIG9wZXJhdG9yLFxuICAgICAgICBhZGRyZXNzIGZyb20sXG4gICAgICAgIHVpbnQyNTYgdG9rZW5JZCxcbiAgICAgICAgYnl0ZXMgY2FsbGRhdGEgZGF0YVxuICAgICkgZXh0ZXJuYWwgcmV0dXJucyAoYnl0ZXM0KTtcbn1cblxuLy8gRmlsZSBAb3BlbnplcHBlbGluL2NvbnRyYWN0cy90b2tlbi9FUkM3MjEvZXh0ZW5zaW9ucy9JRVJDNzIxTWV0YWRhdGEuc29sQHY0LjYuMFxuXG4vLyBPcGVuWmVwcGVsaW4gQ29udHJhY3RzIHY0LjQuMSAodG9rZW4vRVJDNzIxL2V4dGVuc2lvbnMvSUVSQzcyMU1ldGFkYXRhLnNvbClcblxucHJhZ21hIHNvbGlkaXR5IF4wLjguMDtcblxuLyoqXG4gKiBAdGl0bGUgRVJDLTcyMSBOb24tRnVuZ2libGUgVG9rZW4gU3RhbmRhcmQsIG9wdGlvbmFsIG1ldGFkYXRhIGV4dGVuc2lvblxuICogQGRldiBTZWUgaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03MjFcbiAqL1xuaW50ZXJmYWNlIElFUkM3MjFNZXRhZGF0YSBpcyBJRVJDNzIxIHtcbiAgICAvKipcbiAgICAgKiBAZGV2IFJldHVybnMgdGhlIHRva2VuIGNvbGxlY3Rpb24gbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuYW1lKCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChzdHJpbmcgbWVtb3J5KTtcblxuICAgIC8qKlxuICAgICAqIEBkZXYgUmV0dXJucyB0aGUgdG9rZW4gY29sbGVjdGlvbiBzeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ltYm9sKCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChzdHJpbmcgbWVtb3J5KTtcblxuICAgIC8qKlxuICAgICAqIEBkZXYgUmV0dXJucyB0aGUgVW5pZm9ybSBSZXNvdXJjZSBJZGVudGlmaWVyIChVUkkpIGZvciAndG9rZW5JZCcgdG9rZW4uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9rZW5VUkkodWludDI1NiB0b2tlbklkKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHN0cmluZyBtZW1vcnkpO1xufVxuXG4vLyBGaWxlIEBvcGVuemVwcGVsaW4vY29udHJhY3RzL3V0aWxzL0FkZHJlc3Muc29sQHY0LjYuMFxuXG4vLyBPcGVuWmVwcGVsaW4gQ29udHJhY3RzIChsYXN0IHVwZGF0ZWQgdjQuNS4wKSAodXRpbHMvQWRkcmVzcy5zb2wpXG5cbnByYWdtYSBzb2xpZGl0eSBeMC44LjE7XG5cbi8qKlxuICogQGRldiBDb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyByZWxhdGVkIHRvIHRoZSBhZGRyZXNzIHR5cGVcbiAqL1xubGlicmFyeSBBZGRyZXNzIHtcbiAgICAvKipcbiAgICAgKiBAZGV2IFJldHVybnMgdHJ1ZSBpZiAnYWNjb3VudCcgaXMgYSBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIFtJTVBPUlRBTlRdXG4gICAgICogPT09PVxuICAgICAqIEl0IGlzIHVuc2FmZSB0byBhc3N1bWUgdGhhdCBhbiBhZGRyZXNzIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uIHJldHVybnNcbiAgICAgKiBmYWxzZSBpcyBhbiBleHRlcm5hbGx5LW93bmVkIGFjY291bnQgKEVPQSkgYW5kIG5vdCBhIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQW1vbmcgb3RoZXJzLCAnaXNDb250cmFjdCcgd2lsbCByZXR1cm4gZmFsc2UgZm9yIHRoZSBmb2xsb3dpbmdcbiAgICAgKiB0eXBlcyBvZiBhZGRyZXNzZXM6XG4gICAgICpcbiAgICAgKiAgLSBhbiBleHRlcm5hbGx5LW93bmVkIGFjY291bnRcbiAgICAgKiAgLSBhIGNvbnRyYWN0IGluIGNvbnN0cnVjdGlvblxuICAgICAqICAtIGFuIGFkZHJlc3Mgd2hlcmUgYSBjb250cmFjdCB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiAgLSBhbiBhZGRyZXNzIHdoZXJlIGEgY29udHJhY3QgbGl2ZWQsIGJ1dCB3YXMgZGVzdHJveWVkXG4gICAgICogPT09PVxuICAgICAqXG4gICAgICogW0lNUE9SVEFOVF1cbiAgICAgKiA9PT09XG4gICAgICogWW91IHNob3VsZG4ndCByZWx5IG9uICdpc0NvbnRyYWN0JyB0byBwcm90ZWN0IGFnYWluc3QgZmxhc2ggbG9hbiBhdHRhY2tzIVxuICAgICAqXG4gICAgICogUHJldmVudGluZyBjYWxscyBmcm9tIGNvbnRyYWN0cyBpcyBoaWdobHkgZGlzY291cmFnZWQuIEl0IGJyZWFrcyBjb21wb3NhYmlsaXR5LCBicmVha3Mgc3VwcG9ydCBmb3Igc21hcnQgd2FsbGV0c1xuICAgICAqIGxpa2UgR25vc2lzIFNhZmUsIGFuZCBkb2VzIG5vdCBwcm92aWRlIHNlY3VyaXR5IHNpbmNlIGl0IGNhbiBiZSBjaXJjdW12ZW50ZWQgYnkgY2FsbGluZyBmcm9tIGEgY29udHJhY3RcbiAgICAgKiBjb25zdHJ1Y3Rvci5cbiAgICAgKiA9PT09XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNDb250cmFjdChhZGRyZXNzIGFjY291bnQpIGludGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbCkge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCByZWxpZXMgb24gZXh0Y29kZXNpemUvYWRkcmVzcy5jb2RlLmxlbmd0aCwgd2hpY2ggcmV0dXJucyAwXG4gICAgICAgIC8vIGZvciBjb250cmFjdHMgaW4gY29uc3RydWN0aW9uLCBzaW5jZSB0aGUgY29kZSBpcyBvbmx5IHN0b3JlZCBhdCB0aGUgZW5kXG4gICAgICAgIC8vIG9mIHRoZSBjb25zdHJ1Y3RvciBleGVjdXRpb24uXG5cbiAgICAgICAgcmV0dXJuIGFjY291bnQuY29kZS5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgUmVwbGFjZW1lbnQgZm9yIFNvbGlkaXR5J3MgJ3RyYW5zZmVyJzogc2VuZHMgJ2Ftb3VudCcgd2VpIHRvXG4gICAgICogJ3JlY2lwaWVudCcsIGZvcndhcmRpbmcgYWxsIGF2YWlsYWJsZSBnYXMgYW5kIHJldmVydGluZyBvbiBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE4ODRbRUlQMTg4NF0gaW5jcmVhc2VzIHRoZSBnYXMgY29zdFxuICAgICAqIG9mIGNlcnRhaW4gb3Bjb2RlcywgcG9zc2libHkgbWFraW5nIGNvbnRyYWN0cyBnbyBvdmVyIHRoZSAyMzAwIGdhcyBsaW1pdFxuICAgICAqIGltcG9zZWQgYnkgJ3RyYW5zZmVyJywgbWFraW5nIHRoZW0gdW5hYmxlIHRvIHJlY2VpdmUgZnVuZHMgdmlhXG4gICAgICogJ3RyYW5zZmVyJy4ge3NlbmRWYWx1ZX0gcmVtb3ZlcyB0aGlzIGxpbWl0YXRpb24uXG4gICAgICpcbiAgICAgKiBodHRwczovL2RpbGlnZW5jZS5jb25zZW5zeXMubmV0L3Bvc3RzLzIwMTkvMDkvc3RvcC11c2luZy1zb2xpZGl0eXMtdHJhbnNmZXItbm93L1tMZWFybiBtb3JlXS5cbiAgICAgKlxuICAgICAqIElNUE9SVEFOVDogYmVjYXVzZSBjb250cm9sIGlzIHRyYW5zZmVycmVkIHRvICdyZWNpcGllbnQnLCBjYXJlIG11c3QgYmVcbiAgICAgKiB0YWtlbiB0byBub3QgY3JlYXRlIHJlZW50cmFuY3kgdnVsbmVyYWJpbGl0aWVzLiBDb25zaWRlciB1c2luZ1xuICAgICAqIHtSZWVudHJhbmN5R3VhcmR9IG9yIHRoZVxuICAgICAqIGh0dHBzOi8vc29saWRpdHkucmVhZHRoZWRvY3MuaW8vZW4vdjAuNS4xMS9zZWN1cml0eS1jb25zaWRlcmF0aW9ucy5odG1sI3VzZS10aGUtY2hlY2tzLWVmZmVjdHMtaW50ZXJhY3Rpb25zLXBhdHRlcm5bY2hlY2tzLWVmZmVjdHMtaW50ZXJhY3Rpb25zIHBhdHRlcm5dLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlbmRWYWx1ZShhZGRyZXNzIHBheWFibGUgcmVjaXBpZW50LCB1aW50MjU2IGFtb3VudCkgaW50ZXJuYWwge1xuICAgICAgICByZXF1aXJlKFxuICAgICAgICAgICAgYWRkcmVzcyh0aGlzKS5iYWxhbmNlID49IGFtb3VudCxcbiAgICAgICAgICAgIFwiQWRkcmVzczogaW5zdWZmaWNpZW50IGJhbGFuY2VcIlxuICAgICAgICApO1xuXG4gICAgICAgIChib29sIHN1Y2Nlc3MsICkgPSByZWNpcGllbnQuY2FsbHt2YWx1ZTogYW1vdW50fShcIlwiKTtcbiAgICAgICAgcmVxdWlyZShcbiAgICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgICBcIkFkZHJlc3M6IHVuYWJsZSB0byBzZW5kIHZhbHVlLCByZWNpcGllbnQgbWF5IGhhdmUgcmV2ZXJ0ZWRcIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgUGVyZm9ybXMgYSBTb2xpZGl0eSBmdW5jdGlvbiBjYWxsIHVzaW5nIGEgbG93IGxldmVsICdjYWxsJy4gQVxuICAgICAqIHBsYWluICdjYWxsJyBpcyBhbiB1bnNhZmUgcmVwbGFjZW1lbnQgZm9yIGEgZnVuY3Rpb24gY2FsbDogdXNlIHRoaXNcbiAgICAgKiBmdW5jdGlvbiBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogSWYgJ3RhcmdldCcgcmV2ZXJ0cyB3aXRoIGEgcmV2ZXJ0IHJlYXNvbiwgaXQgaXMgYnViYmxlZCB1cCBieSB0aGlzXG4gICAgICogZnVuY3Rpb24gKGxpa2UgcmVndWxhciBTb2xpZGl0eSBmdW5jdGlvbiBjYWxscykuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSByYXcgcmV0dXJuZWQgZGF0YS4gVG8gY29udmVydCB0byB0aGUgZXhwZWN0ZWQgcmV0dXJuIHZhbHVlLFxuICAgICAqIHVzZSBodHRwczovL3NvbGlkaXR5LnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC91bml0cy1hbmQtZ2xvYmFsLXZhcmlhYmxlcy5odG1sP2hpZ2hsaWdodD1hYmkuZGVjb2RlI2FiaS1lbmNvZGluZy1hbmQtZGVjb2RpbmctZnVuY3Rpb25zWydhYmkuZGVjb2RlJ10uXG4gICAgICpcbiAgICAgKiBSZXF1aXJlbWVudHM6XG4gICAgICpcbiAgICAgKiAtICd0YXJnZXQnIG11c3QgYmUgYSBjb250cmFjdC5cbiAgICAgKiAtIGNhbGxpbmcgJ3RhcmdldCcgd2l0aCAnZGF0YScgbXVzdCBub3QgcmV2ZXJ0LlxuICAgICAqXG4gICAgICogX0F2YWlsYWJsZSBzaW5jZSB2My4xLl9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbkNhbGwoYWRkcmVzcyB0YXJnZXQsIGJ5dGVzIG1lbW9yeSBkYXRhKVxuICAgICAgICBpbnRlcm5hbFxuICAgICAgICByZXR1cm5zIChieXRlcyBtZW1vcnkpXG4gICAge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxsKHRhcmdldCwgZGF0YSwgXCJBZGRyZXNzOiBsb3ctbGV2ZWwgY2FsbCBmYWlsZWRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBTYW1lIGFzIHt4cmVmLUFkZHJlc3MtZnVuY3Rpb25DYWxsLWFkZHJlc3MtYnl0ZXMtfVsnZnVuY3Rpb25DYWxsJ10sIGJ1dCB3aXRoXG4gICAgICogJ2Vycm9yTWVzc2FnZScgYXMgYSBmYWxsYmFjayByZXZlcnQgcmVhc29uIHdoZW4gJ3RhcmdldCcgcmV2ZXJ0cy5cbiAgICAgKlxuICAgICAqIF9BdmFpbGFibGUgc2luY2UgdjMuMS5fXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25DYWxsKFxuICAgICAgICBhZGRyZXNzIHRhcmdldCxcbiAgICAgICAgYnl0ZXMgbWVtb3J5IGRhdGEsXG4gICAgICAgIHN0cmluZyBtZW1vcnkgZXJyb3JNZXNzYWdlXG4gICAgKSBpbnRlcm5hbCByZXR1cm5zIChieXRlcyBtZW1vcnkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2FsbFdpdGhWYWx1ZSh0YXJnZXQsIGRhdGEsIDAsIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBTYW1lIGFzIHt4cmVmLUFkZHJlc3MtZnVuY3Rpb25DYWxsLWFkZHJlc3MtYnl0ZXMtfVsnZnVuY3Rpb25DYWxsJ10sXG4gICAgICogYnV0IGFsc28gdHJhbnNmZXJyaW5nICd2YWx1ZScgd2VpIHRvICd0YXJnZXQnLlxuICAgICAqXG4gICAgICogUmVxdWlyZW1lbnRzOlxuICAgICAqXG4gICAgICogLSB0aGUgY2FsbGluZyBjb250cmFjdCBtdXN0IGhhdmUgYW4gRVRIIGJhbGFuY2Ugb2YgYXQgbGVhc3QgJ3ZhbHVlJy5cbiAgICAgKiAtIHRoZSBjYWxsZWQgU29saWRpdHkgZnVuY3Rpb24gbXVzdCBiZSAncGF5YWJsZScuXG4gICAgICpcbiAgICAgKiBfQXZhaWxhYmxlIHNpbmNlIHYzLjEuX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFdpdGhWYWx1ZShcbiAgICAgICAgYWRkcmVzcyB0YXJnZXQsXG4gICAgICAgIGJ5dGVzIG1lbW9yeSBkYXRhLFxuICAgICAgICB1aW50MjU2IHZhbHVlXG4gICAgKSBpbnRlcm5hbCByZXR1cm5zIChieXRlcyBtZW1vcnkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICBmdW5jdGlvbkNhbGxXaXRoVmFsdWUoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgXCJBZGRyZXNzOiBsb3ctbGV2ZWwgY2FsbCB3aXRoIHZhbHVlIGZhaWxlZFwiXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgU2FtZSBhcyB7eHJlZi1BZGRyZXNzLWZ1bmN0aW9uQ2FsbFdpdGhWYWx1ZS1hZGRyZXNzLWJ5dGVzLXVpbnQyNTYtfVsnZnVuY3Rpb25DYWxsV2l0aFZhbHVlJ10sIGJ1dFxuICAgICAqIHdpdGggJ2Vycm9yTWVzc2FnZScgYXMgYSBmYWxsYmFjayByZXZlcnQgcmVhc29uIHdoZW4gJ3RhcmdldCcgcmV2ZXJ0cy5cbiAgICAgKlxuICAgICAqIF9BdmFpbGFibGUgc2luY2UgdjMuMS5fXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25DYWxsV2l0aFZhbHVlKFxuICAgICAgICBhZGRyZXNzIHRhcmdldCxcbiAgICAgICAgYnl0ZXMgbWVtb3J5IGRhdGEsXG4gICAgICAgIHVpbnQyNTYgdmFsdWUsXG4gICAgICAgIHN0cmluZyBtZW1vcnkgZXJyb3JNZXNzYWdlXG4gICAgKSBpbnRlcm5hbCByZXR1cm5zIChieXRlcyBtZW1vcnkpIHtcbiAgICAgICAgcmVxdWlyZShcbiAgICAgICAgICAgIGFkZHJlc3ModGhpcykuYmFsYW5jZSA+PSB2YWx1ZSxcbiAgICAgICAgICAgIFwiQWRkcmVzczogaW5zdWZmaWNpZW50IGJhbGFuY2UgZm9yIGNhbGxcIlxuICAgICAgICApO1xuICAgICAgICByZXF1aXJlKGlzQ29udHJhY3QodGFyZ2V0KSwgXCJBZGRyZXNzOiBjYWxsIHRvIG5vbi1jb250cmFjdFwiKTtcblxuICAgICAgICAoYm9vbCBzdWNjZXNzLCBieXRlcyBtZW1vcnkgcmV0dXJuZGF0YSkgPSB0YXJnZXQuY2FsbHt2YWx1ZTogdmFsdWV9KFxuICAgICAgICAgICAgZGF0YVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdmVyaWZ5Q2FsbFJlc3VsdChzdWNjZXNzLCByZXR1cm5kYXRhLCBlcnJvck1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgU2FtZSBhcyB7eHJlZi1BZGRyZXNzLWZ1bmN0aW9uQ2FsbC1hZGRyZXNzLWJ5dGVzLX1bJ2Z1bmN0aW9uQ2FsbCddLFxuICAgICAqIGJ1dCBwZXJmb3JtaW5nIGEgc3RhdGljIGNhbGwuXG4gICAgICpcbiAgICAgKiBfQXZhaWxhYmxlIHNpbmNlIHYzLjMuX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3RhdGljQ2FsbChhZGRyZXNzIHRhcmdldCwgYnl0ZXMgbWVtb3J5IGRhdGEpXG4gICAgICAgIGludGVybmFsXG4gICAgICAgIHZpZXdcbiAgICAgICAgcmV0dXJucyAoYnl0ZXMgbWVtb3J5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICBmdW5jdGlvblN0YXRpY0NhbGwoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgXCJBZGRyZXNzOiBsb3ctbGV2ZWwgc3RhdGljIGNhbGwgZmFpbGVkXCJcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBTYW1lIGFzIHt4cmVmLUFkZHJlc3MtZnVuY3Rpb25DYWxsLWFkZHJlc3MtYnl0ZXMtc3RyaW5nLX1bJ2Z1bmN0aW9uQ2FsbCddLFxuICAgICAqIGJ1dCBwZXJmb3JtaW5nIGEgc3RhdGljIGNhbGwuXG4gICAgICpcbiAgICAgKiBfQXZhaWxhYmxlIHNpbmNlIHYzLjMuX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uU3RhdGljQ2FsbChcbiAgICAgICAgYWRkcmVzcyB0YXJnZXQsXG4gICAgICAgIGJ5dGVzIG1lbW9yeSBkYXRhLFxuICAgICAgICBzdHJpbmcgbWVtb3J5IGVycm9yTWVzc2FnZVxuICAgICkgaW50ZXJuYWwgdmlldyByZXR1cm5zIChieXRlcyBtZW1vcnkpIHtcbiAgICAgICAgcmVxdWlyZShpc0NvbnRyYWN0KHRhcmdldCksIFwiQWRkcmVzczogc3RhdGljIGNhbGwgdG8gbm9uLWNvbnRyYWN0XCIpO1xuXG4gICAgICAgIChib29sIHN1Y2Nlc3MsIGJ5dGVzIG1lbW9yeSByZXR1cm5kYXRhKSA9IHRhcmdldC5zdGF0aWNjYWxsKGRhdGEpO1xuICAgICAgICByZXR1cm4gdmVyaWZ5Q2FsbFJlc3VsdChzdWNjZXNzLCByZXR1cm5kYXRhLCBlcnJvck1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgU2FtZSBhcyB7eHJlZi1BZGRyZXNzLWZ1bmN0aW9uQ2FsbC1hZGRyZXNzLWJ5dGVzLX1bJ2Z1bmN0aW9uQ2FsbCddLFxuICAgICAqIGJ1dCBwZXJmb3JtaW5nIGEgZGVsZWdhdGUgY2FsbC5cbiAgICAgKlxuICAgICAqIF9BdmFpbGFibGUgc2luY2UgdjMuNC5fXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25EZWxlZ2F0ZUNhbGwoYWRkcmVzcyB0YXJnZXQsIGJ5dGVzIG1lbW9yeSBkYXRhKVxuICAgICAgICBpbnRlcm5hbFxuICAgICAgICByZXR1cm5zIChieXRlcyBtZW1vcnkpXG4gICAge1xuICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIGZ1bmN0aW9uRGVsZWdhdGVDYWxsKFxuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIFwiQWRkcmVzczogbG93LWxldmVsIGRlbGVnYXRlIGNhbGwgZmFpbGVkXCJcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBTYW1lIGFzIHt4cmVmLUFkZHJlc3MtZnVuY3Rpb25DYWxsLWFkZHJlc3MtYnl0ZXMtc3RyaW5nLX1bJ2Z1bmN0aW9uQ2FsbCddLFxuICAgICAqIGJ1dCBwZXJmb3JtaW5nIGEgZGVsZWdhdGUgY2FsbC5cbiAgICAgKlxuICAgICAqIF9BdmFpbGFibGUgc2luY2UgdjMuNC5fXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25EZWxlZ2F0ZUNhbGwoXG4gICAgICAgIGFkZHJlc3MgdGFyZ2V0LFxuICAgICAgICBieXRlcyBtZW1vcnkgZGF0YSxcbiAgICAgICAgc3RyaW5nIG1lbW9yeSBlcnJvck1lc3NhZ2VcbiAgICApIGludGVybmFsIHJldHVybnMgKGJ5dGVzIG1lbW9yeSkge1xuICAgICAgICByZXF1aXJlKGlzQ29udHJhY3QodGFyZ2V0KSwgXCJBZGRyZXNzOiBkZWxlZ2F0ZSBjYWxsIHRvIG5vbi1jb250cmFjdFwiKTtcblxuICAgICAgICAoYm9vbCBzdWNjZXNzLCBieXRlcyBtZW1vcnkgcmV0dXJuZGF0YSkgPSB0YXJnZXQuZGVsZWdhdGVjYWxsKGRhdGEpO1xuICAgICAgICByZXR1cm4gdmVyaWZ5Q2FsbFJlc3VsdChzdWNjZXNzLCByZXR1cm5kYXRhLCBlcnJvck1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgVG9vbCB0byB2ZXJpZmllcyB0aGF0IGEgbG93IGxldmVsIGNhbGwgd2FzIHN1Y2Nlc3NmdWwsIGFuZCByZXZlcnQgaWYgaXQgd2Fzbid0LCBlaXRoZXIgYnkgYnViYmxpbmcgdGhlXG4gICAgICogcmV2ZXJ0IHJlYXNvbiB1c2luZyB0aGUgcHJvdmlkZWQgb25lLlxuICAgICAqXG4gICAgICogX0F2YWlsYWJsZSBzaW5jZSB2NC4zLl9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnlDYWxsUmVzdWx0KFxuICAgICAgICBib29sIHN1Y2Nlc3MsXG4gICAgICAgIGJ5dGVzIG1lbW9yeSByZXR1cm5kYXRhLFxuICAgICAgICBzdHJpbmcgbWVtb3J5IGVycm9yTWVzc2FnZVxuICAgICkgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChieXRlcyBtZW1vcnkpIHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgcmV2ZXJ0IHJlYXNvbiBhbmQgYnViYmxlIGl0IHVwIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChyZXR1cm5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZWFzaWVzdCB3YXkgdG8gYnViYmxlIHRoZSByZXZlcnQgcmVhc29uIGlzIHVzaW5nIG1lbW9yeSB2aWEgYXNzZW1ibHlcblxuICAgICAgICAgICAgICAgIGFzc2VtYmx5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVybmRhdGFfc2l6ZSA6PSBtbG9hZChyZXR1cm5kYXRhKVxuICAgICAgICAgICAgICAgICAgICByZXZlcnQoYWRkKDMyLCByZXR1cm5kYXRhKSwgcmV0dXJuZGF0YV9zaXplKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJ0KGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIEZpbGUgQG9wZW56ZXBwZWxpbi9jb250cmFjdHMvdXRpbHMvQ29udGV4dC5zb2xAdjQuNi4wXG5cbi8vIE9wZW5aZXBwZWxpbiBDb250cmFjdHMgdjQuNC4xICh1dGlscy9Db250ZXh0LnNvbClcblxucHJhZ21hIHNvbGlkaXR5IF4wLjguMDtcblxuLyoqXG4gKiBAZGV2IFByb3ZpZGVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0LCBpbmNsdWRpbmcgdGhlXG4gKiBzZW5kZXIgb2YgdGhlIHRyYW5zYWN0aW9uIGFuZCBpdHMgZGF0YS4gV2hpbGUgdGhlc2UgYXJlIGdlbmVyYWxseSBhdmFpbGFibGVcbiAqIHZpYSBtc2cuc2VuZGVyIGFuZCBtc2cuZGF0YSwgdGhleSBzaG91bGQgbm90IGJlIGFjY2Vzc2VkIGluIHN1Y2ggYSBkaXJlY3RcbiAqIG1hbm5lciwgc2luY2Ugd2hlbiBkZWFsaW5nIHdpdGggbWV0YS10cmFuc2FjdGlvbnMgdGhlIGFjY291bnQgc2VuZGluZyBhbmRcbiAqIHBheWluZyBmb3IgZXhlY3V0aW9uIG1heSBub3QgYmUgdGhlIGFjdHVhbCBzZW5kZXIgKGFzIGZhciBhcyBhbiBhcHBsaWNhdGlvblxuICogaXMgY29uY2VybmVkKS5cbiAqXG4gKiBUaGlzIGNvbnRyYWN0IGlzIG9ubHkgcmVxdWlyZWQgZm9yIGludGVybWVkaWF0ZSwgbGlicmFyeS1saWtlIGNvbnRyYWN0cy5cbiAqL1xuYWJzdHJhY3QgY29udHJhY3QgQ29udGV4dCB7XG4gICAgZnVuY3Rpb24gX21zZ1NlbmRlcigpIGludGVybmFsIHZpZXcgdmlydHVhbCByZXR1cm5zIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBtc2cuc2VuZGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9tc2dEYXRhKCkgaW50ZXJuYWwgdmlldyB2aXJ0dWFsIHJldHVybnMgKGJ5dGVzIGNhbGxkYXRhKSB7XG4gICAgICAgIHJldHVybiBtc2cuZGF0YTtcbiAgICB9XG59XG5cbi8vIEZpbGUgQG9wZW56ZXBwZWxpbi9jb250cmFjdHMvdXRpbHMvU3RyaW5ncy5zb2xAdjQuNi4wXG5cbi8vIE9wZW5aZXBwZWxpbiBDb250cmFjdHMgdjQuNC4xICh1dGlscy9TdHJpbmdzLnNvbClcblxucHJhZ21hIHNvbGlkaXR5IF4wLjguMDtcblxuLyoqXG4gKiBAZGV2IFN0cmluZyBvcGVyYXRpb25zLlxuICovXG5saWJyYXJ5IFN0cmluZ3Mge1xuICAgIGJ5dGVzMTYgcHJpdmF0ZSBjb25zdGFudCBfSEVYX1NZTUJPTFMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcblxuICAgIC8qKlxuICAgICAqIEBkZXYgQ29udmVydHMgYSAndWludDI1NicgdG8gaXRzIEFTQ0lJICdzdHJpbmcnIGRlY2ltYWwgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodWludDI1NiB2YWx1ZSkgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChzdHJpbmcgbWVtb3J5KSB7XG4gICAgICAgIC8vIEluc3BpcmVkIGJ5IE9yYWNsaXplQVBJJ3MgaW1wbGVtZW50YXRpb24gLSBNSVQgbGljZW5jZVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb3JhY2xpemUvZXRoZXJldW0tYXBpL2Jsb2IvYjQyMTQ2YjA2M2M3ZDZlZTEzNTg4NDZjMTk4MjQ2MjM5ZTkzNjBlOC9vcmFjbGl6ZUFQSV8wLjQuMjUuc29sXG5cbiAgICAgICAgaWYgKHZhbHVlID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICB1aW50MjU2IHRlbXAgPSB2YWx1ZTtcbiAgICAgICAgdWludDI1NiBkaWdpdHM7XG4gICAgICAgIHdoaWxlICh0ZW1wICE9IDApIHtcbiAgICAgICAgICAgIGRpZ2l0cysrO1xuICAgICAgICAgICAgdGVtcCAvPSAxMDtcbiAgICAgICAgfVxuICAgICAgICBieXRlcyBtZW1vcnkgYnVmZmVyID0gbmV3IGJ5dGVzKGRpZ2l0cyk7XG4gICAgICAgIHdoaWxlICh2YWx1ZSAhPSAwKSB7XG4gICAgICAgICAgICBkaWdpdHMgLT0gMTtcbiAgICAgICAgICAgIGJ1ZmZlcltkaWdpdHNdID0gYnl0ZXMxKHVpbnQ4KDQ4ICsgdWludDI1Nih2YWx1ZSAlIDEwKSkpO1xuICAgICAgICAgICAgdmFsdWUgLz0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZyhidWZmZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgQ29udmVydHMgYSAndWludDI1NicgdG8gaXRzIEFTQ0lJICdzdHJpbmcnIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSGV4U3RyaW5nKHVpbnQyNTYgdmFsdWUpIGludGVybmFsIHB1cmUgcmV0dXJucyAoc3RyaW5nIG1lbW9yeSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMHgwMFwiO1xuICAgICAgICB9XG4gICAgICAgIHVpbnQyNTYgdGVtcCA9IHZhbHVlO1xuICAgICAgICB1aW50MjU2IGxlbmd0aCA9IDA7XG4gICAgICAgIHdoaWxlICh0ZW1wICE9IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgICAgdGVtcCA+Pj0gODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9IZXhTdHJpbmcodmFsdWUsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBDb252ZXJ0cyBhICd1aW50MjU2JyB0byBpdHMgQVNDSUkgJ3N0cmluZycgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gd2l0aCBmaXhlZCBsZW5ndGguXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9IZXhTdHJpbmcodWludDI1NiB2YWx1ZSwgdWludDI1NiBsZW5ndGgpXG4gICAgICAgIGludGVybmFsXG4gICAgICAgIHB1cmVcbiAgICAgICAgcmV0dXJucyAoc3RyaW5nIG1lbW9yeSlcbiAgICB7XG4gICAgICAgIGJ5dGVzIG1lbW9yeSBidWZmZXIgPSBuZXcgYnl0ZXMoMiAqIGxlbmd0aCArIDIpO1xuICAgICAgICBidWZmZXJbMF0gPSBcIjBcIjtcbiAgICAgICAgYnVmZmVyWzFdID0gXCJ4XCI7XG4gICAgICAgIGZvciAodWludDI1NiBpID0gMiAqIGxlbmd0aCArIDE7IGkgPiAxOyAtLWkpIHtcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IF9IRVhfU1lNQk9MU1t2YWx1ZSAmIDB4Zl07XG4gICAgICAgICAgICB2YWx1ZSA+Pj0gNDtcbiAgICAgICAgfVxuICAgICAgICByZXF1aXJlKHZhbHVlID09IDAsIFwiU3RyaW5nczogaGV4IGxlbmd0aCBpbnN1ZmZpY2llbnRcIik7XG4gICAgICAgIHJldHVybiBzdHJpbmcoYnVmZmVyKTtcbiAgICB9XG59XG5cbi8vIEZpbGUgQG9wZW56ZXBwZWxpbi9jb250cmFjdHMvdXRpbHMvaW50cm9zcGVjdGlvbi9FUkMxNjUuc29sQHY0LjYuMFxuXG4vLyBPcGVuWmVwcGVsaW4gQ29udHJhY3RzIHY0LjQuMSAodXRpbHMvaW50cm9zcGVjdGlvbi9FUkMxNjUuc29sKVxuXG5wcmFnbWEgc29saWRpdHkgXjAuOC4wO1xuXG4vKipcbiAqIEBkZXYgSW1wbGVtZW50YXRpb24gb2YgdGhlIHtJRVJDMTY1fSBpbnRlcmZhY2UuXG4gKlxuICogQ29udHJhY3RzIHRoYXQgd2FudCB0byBpbXBsZW1lbnQgRVJDMTY1IHNob3VsZCBpbmhlcml0IGZyb20gdGhpcyBjb250cmFjdCBhbmQgb3ZlcnJpZGUge3N1cHBvcnRzSW50ZXJmYWNlfSB0byBjaGVja1xuICogZm9yIHRoZSBhZGRpdGlvbmFsIGludGVyZmFjZSBpZCB0aGF0IHdpbGwgYmUgc3VwcG9ydGVkLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAnJydzb2xpZGl0eVxuICogZnVuY3Rpb24gc3VwcG9ydHNJbnRlcmZhY2UoYnl0ZXM0IGludGVyZmFjZUlkKSBwdWJsaWMgdmlldyB2aXJ0dWFsIG92ZXJyaWRlIHJldHVybnMgKGJvb2wpIHtcbiAqICAgICByZXR1cm4gaW50ZXJmYWNlSWQgPT0gdHlwZShNeUludGVyZmFjZSkuaW50ZXJmYWNlSWQgfHwgc3VwZXIuc3VwcG9ydHNJbnRlcmZhY2UoaW50ZXJmYWNlSWQpO1xuICogfVxuICogJycnXG4gKlxuICogQWx0ZXJuYXRpdmVseSwge0VSQzE2NVN0b3JhZ2V9IHByb3ZpZGVzIGFuIGVhc2llciB0byB1c2UgYnV0IG1vcmUgZXhwZW5zaXZlIGltcGxlbWVudGF0aW9uLlxuICovXG5hYnN0cmFjdCBjb250cmFjdCBFUkMxNjUgaXMgSUVSQzE2NSB7XG4gICAgLyoqXG4gICAgICogQGRldiBTZWUge0lFUkMxNjUtc3VwcG9ydHNJbnRlcmZhY2V9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1cHBvcnRzSW50ZXJmYWNlKGJ5dGVzNCBpbnRlcmZhY2VJZClcbiAgICAgICAgcHVibGljXG4gICAgICAgIHZpZXdcbiAgICAgICAgdmlydHVhbFxuICAgICAgICBvdmVycmlkZVxuICAgICAgICByZXR1cm5zIChib29sKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUlkID09IHR5cGUoSUVSQzE2NSkuaW50ZXJmYWNlSWQ7XG4gICAgfVxufVxuXG4vLyBGaWxlIEBvcGVuemVwcGVsaW4vY29udHJhY3RzL3Rva2VuL0VSQzcyMS9FUkM3MjEuc29sQHY0LjYuMFxuXG4vLyBPcGVuWmVwcGVsaW4gQ29udHJhY3RzIChsYXN0IHVwZGF0ZWQgdjQuNi4wKSAodG9rZW4vRVJDNzIxL0VSQzcyMS5zb2wpXG5cbnByYWdtYSBzb2xpZGl0eSBeMC44LjA7XG5cbi8qKlxuICogQGRldiBJbXBsZW1lbnRhdGlvbiBvZiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcyMVtFUkM3MjFdIE5vbi1GdW5naWJsZSBUb2tlbiBTdGFuZGFyZCwgaW5jbHVkaW5nXG4gKiB0aGUgTWV0YWRhdGEgZXh0ZW5zaW9uLCBidXQgbm90IGluY2x1ZGluZyB0aGUgRW51bWVyYWJsZSBleHRlbnNpb24sIHdoaWNoIGlzIGF2YWlsYWJsZSBzZXBhcmF0ZWx5IGFzXG4gKiB7RVJDNzIxRW51bWVyYWJsZX0uXG4gKi9cbmNvbnRyYWN0IEVSQzcyMSBpcyBDb250ZXh0LCBFUkMxNjUsIElFUkM3MjEsIElFUkM3MjFNZXRhZGF0YSB7XG4gICAgdXNpbmcgQWRkcmVzcyBmb3IgYWRkcmVzcztcbiAgICB1c2luZyBTdHJpbmdzIGZvciB1aW50MjU2O1xuXG4gICAgLy8gVG9rZW4gbmFtZVxuICAgIHN0cmluZyBwcml2YXRlIF9uYW1lO1xuXG4gICAgLy8gVG9rZW4gc3ltYm9sXG4gICAgc3RyaW5nIHByaXZhdGUgX3N5bWJvbDtcblxuICAgIC8vIE1hcHBpbmcgZnJvbSB0b2tlbiBJRCB0byBvd25lciBhZGRyZXNzXG4gICAgbWFwcGluZyh1aW50MjU2ID0+IGFkZHJlc3MpIHByaXZhdGUgX293bmVycztcblxuICAgIC8vIE1hcHBpbmcgb3duZXIgYWRkcmVzcyB0byB0b2tlbiBjb3VudFxuICAgIG1hcHBpbmcoYWRkcmVzcyA9PiB1aW50MjU2KSBwcml2YXRlIF9iYWxhbmNlcztcblxuICAgIC8vIE1hcHBpbmcgZnJvbSB0b2tlbiBJRCB0byBhcHByb3ZlZCBhZGRyZXNzXG4gICAgbWFwcGluZyh1aW50MjU2ID0+IGFkZHJlc3MpIHByaXZhdGUgX3Rva2VuQXBwcm92YWxzO1xuXG4gICAgLy8gTWFwcGluZyBmcm9tIG93bmVyIHRvIG9wZXJhdG9yIGFwcHJvdmFsc1xuICAgIG1hcHBpbmcoYWRkcmVzcyA9PiBtYXBwaW5nKGFkZHJlc3MgPT4gYm9vbCkpIHByaXZhdGUgX29wZXJhdG9yQXBwcm92YWxzO1xuXG4gICAgLyoqXG4gICAgICogQGRldiBJbml0aWFsaXplcyB0aGUgY29udHJhY3QgYnkgc2V0dGluZyBhICduYW1lJyBhbmQgYSAnc3ltYm9sJyB0byB0aGUgdG9rZW4gY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcgbWVtb3J5IG5hbWVfLCBzdHJpbmcgbWVtb3J5IHN5bWJvbF8pIHtcbiAgICAgICAgX25hbWUgPSBuYW1lXztcbiAgICAgICAgX3N5bWJvbCA9IHN5bWJvbF87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBTZWUge0lFUkMxNjUtc3VwcG9ydHNJbnRlcmZhY2V9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1cHBvcnRzSW50ZXJmYWNlKGJ5dGVzNCBpbnRlcmZhY2VJZClcbiAgICAgICAgcHVibGljXG4gICAgICAgIHZpZXdcbiAgICAgICAgdmlydHVhbFxuICAgICAgICBvdmVycmlkZShFUkMxNjUsIElFUkMxNjUpXG4gICAgICAgIHJldHVybnMgKGJvb2wpXG4gICAge1xuICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIGludGVyZmFjZUlkID09IHR5cGUoSUVSQzcyMSkuaW50ZXJmYWNlSWQgfHxcbiAgICAgICAgICAgIGludGVyZmFjZUlkID09IHR5cGUoSUVSQzcyMU1ldGFkYXRhKS5pbnRlcmZhY2VJZCB8fFxuICAgICAgICAgICAgc3VwZXIuc3VwcG9ydHNJbnRlcmZhY2UoaW50ZXJmYWNlSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgU2VlIHtJRVJDNzIxLWJhbGFuY2VPZn0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3Mgb3duZXIpXG4gICAgICAgIHB1YmxpY1xuICAgICAgICB2aWV3XG4gICAgICAgIHZpcnR1YWxcbiAgICAgICAgb3ZlcnJpZGVcbiAgICAgICAgcmV0dXJucyAodWludDI1NilcbiAgICB7XG4gICAgICAgIHJlcXVpcmUoXG4gICAgICAgICAgICBvd25lciAhPSBhZGRyZXNzKDApLFxuICAgICAgICAgICAgXCJFUkM3MjE6IGJhbGFuY2UgcXVlcnkgZm9yIHRoZSB6ZXJvIGFkZHJlc3NcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gX2JhbGFuY2VzW293bmVyXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFNlZSB7SUVSQzcyMS1vd25lck9mfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvd25lck9mKHVpbnQyNTYgdG9rZW5JZClcbiAgICAgICAgcHVibGljXG4gICAgICAgIHZpZXdcbiAgICAgICAgdmlydHVhbFxuICAgICAgICBvdmVycmlkZVxuICAgICAgICByZXR1cm5zIChhZGRyZXNzKVxuICAgIHtcbiAgICAgICAgYWRkcmVzcyBvd25lciA9IF9vd25lcnNbdG9rZW5JZF07XG4gICAgICAgIHJlcXVpcmUoXG4gICAgICAgICAgICBvd25lciAhPSBhZGRyZXNzKDApLFxuICAgICAgICAgICAgXCJFUkM3MjE6IG93bmVyIHF1ZXJ5IGZvciBub25leGlzdGVudCB0b2tlblwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBvd25lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFNlZSB7SUVSQzcyMU1ldGFkYXRhLW5hbWV9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5hbWUoKSBwdWJsaWMgdmlldyB2aXJ0dWFsIG92ZXJyaWRlIHJldHVybnMgKHN0cmluZyBtZW1vcnkpIHtcbiAgICAgICAgcmV0dXJuIF9uYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgU2VlIHtJRVJDNzIxTWV0YWRhdGEtc3ltYm9sfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzeW1ib2woKSBwdWJsaWMgdmlldyB2aXJ0dWFsIG92ZXJyaWRlIHJldHVybnMgKHN0cmluZyBtZW1vcnkpIHtcbiAgICAgICAgcmV0dXJuIF9zeW1ib2w7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBTZWUge0lFUkM3MjFNZXRhZGF0YS10b2tlblVSSX0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9rZW5VUkkodWludDI1NiB0b2tlbklkKVxuICAgICAgICBwdWJsaWNcbiAgICAgICAgdmlld1xuICAgICAgICB2aXJ0dWFsXG4gICAgICAgIG92ZXJyaWRlXG4gICAgICAgIHJldHVybnMgKHN0cmluZyBtZW1vcnkpXG4gICAge1xuICAgICAgICByZXF1aXJlKFxuICAgICAgICAgICAgX2V4aXN0cyh0b2tlbklkKSxcbiAgICAgICAgICAgIFwiRVJDNzIxTWV0YWRhdGE6IFVSSSBxdWVyeSBmb3Igbm9uZXhpc3RlbnQgdG9rZW5cIlxuICAgICAgICApO1xuXG4gICAgICAgIHN0cmluZyBtZW1vcnkgYmFzZVVSSSA9IF9iYXNlVVJJKCk7XG4gICAgICAgIHJldHVyblxuICAgICAgICAgICAgYnl0ZXMoYmFzZVVSSSkubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gc3RyaW5nKGFiaS5lbmNvZGVQYWNrZWQoYmFzZVVSSSwgdG9rZW5JZC50b1N0cmluZygpKSlcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBCYXNlIFVSSSBmb3IgY29tcHV0aW5nIHt0b2tlblVSSX0uIElmIHNldCwgdGhlIHJlc3VsdGluZyBVUkkgZm9yIGVhY2hcbiAgICAgKiB0b2tlbiB3aWxsIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSAnYmFzZVVSSScgYW5kIHRoZSAndG9rZW5JZCcuIEVtcHR5XG4gICAgICogYnkgZGVmYXVsdCwgY2FuIGJlIG92ZXJyaWRkZW4gaW4gY2hpbGQgY29udHJhY3RzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9iYXNlVVJJKCkgaW50ZXJuYWwgdmlldyB2aXJ0dWFsIHJldHVybnMgKHN0cmluZyBtZW1vcnkpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBTZWUge0lFUkM3MjEtYXBwcm92ZX0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXBwcm92ZShhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpIHB1YmxpYyB2aXJ0dWFsIG92ZXJyaWRlIHtcbiAgICAgICAgYWRkcmVzcyBvd25lciA9IEVSQzcyMS5vd25lck9mKHRva2VuSWQpO1xuICAgICAgICByZXF1aXJlKHRvICE9IG93bmVyLCBcIkVSQzcyMTogYXBwcm92YWwgdG8gY3VycmVudCBvd25lclwiKTtcblxuICAgICAgICByZXF1aXJlKFxuICAgICAgICAgICAgX21zZ1NlbmRlcigpID09IG93bmVyIHx8IGlzQXBwcm92ZWRGb3JBbGwob3duZXIsIF9tc2dTZW5kZXIoKSksXG4gICAgICAgICAgICBcIkVSQzcyMTogYXBwcm92ZSBjYWxsZXIgaXMgbm90IG93bmVyIG5vciBhcHByb3ZlZCBmb3IgYWxsXCJcbiAgICAgICAgKTtcblxuICAgICAgICBfYXBwcm92ZSh0bywgdG9rZW5JZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBTZWUge0lFUkM3MjEtZ2V0QXBwcm92ZWR9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFwcHJvdmVkKHVpbnQyNTYgdG9rZW5JZClcbiAgICAgICAgcHVibGljXG4gICAgICAgIHZpZXdcbiAgICAgICAgdmlydHVhbFxuICAgICAgICBvdmVycmlkZVxuICAgICAgICByZXR1cm5zIChhZGRyZXNzKVxuICAgIHtcbiAgICAgICAgcmVxdWlyZShcbiAgICAgICAgICAgIF9leGlzdHModG9rZW5JZCksXG4gICAgICAgICAgICBcIkVSQzcyMTogYXBwcm92ZWQgcXVlcnkgZm9yIG5vbmV4aXN0ZW50IHRva2VuXCJcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gX3Rva2VuQXBwcm92YWxzW3Rva2VuSWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgU2VlIHtJRVJDNzIxLXNldEFwcHJvdmFsRm9yQWxsfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRBcHByb3ZhbEZvckFsbChhZGRyZXNzIG9wZXJhdG9yLCBib29sIGFwcHJvdmVkKVxuICAgICAgICBwdWJsaWNcbiAgICAgICAgdmlydHVhbFxuICAgICAgICBvdmVycmlkZVxuICAgIHtcbiAgICAgICAgX3NldEFwcHJvdmFsRm9yQWxsKF9tc2dTZW5kZXIoKSwgb3BlcmF0b3IsIGFwcHJvdmVkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFNlZSB7SUVSQzcyMS1pc0FwcHJvdmVkRm9yQWxsfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FwcHJvdmVkRm9yQWxsKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3Mgb3BlcmF0b3IpXG4gICAgICAgIHB1YmxpY1xuICAgICAgICB2aWV3XG4gICAgICAgIHZpcnR1YWxcbiAgICAgICAgb3ZlcnJpZGVcbiAgICAgICAgcmV0dXJucyAoYm9vbClcbiAgICB7XG4gICAgICAgIHJldHVybiBfb3BlcmF0b3JBcHByb3ZhbHNbb3duZXJdW29wZXJhdG9yXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFNlZSB7SUVSQzcyMS10cmFuc2ZlckZyb219LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZmVyRnJvbShcbiAgICAgICAgYWRkcmVzcyBmcm9tLFxuICAgICAgICBhZGRyZXNzIHRvLFxuICAgICAgICB1aW50MjU2IHRva2VuSWRcbiAgICApIHB1YmxpYyB2aXJ0dWFsIG92ZXJyaWRlIHtcbiAgICAgICAgLy9zb2xoaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lLWxlbmd0aFxuICAgICAgICByZXF1aXJlKFxuICAgICAgICAgICAgX2lzQXBwcm92ZWRPck93bmVyKF9tc2dTZW5kZXIoKSwgdG9rZW5JZCksXG4gICAgICAgICAgICBcIkVSQzcyMTogdHJhbnNmZXIgY2FsbGVyIGlzIG5vdCBvd25lciBub3IgYXBwcm92ZWRcIlxuICAgICAgICApO1xuXG4gICAgICAgIF90cmFuc2Zlcihmcm9tLCB0bywgdG9rZW5JZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBTZWUge0lFUkM3MjEtc2FmZVRyYW5zZmVyRnJvbX0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FmZVRyYW5zZmVyRnJvbShcbiAgICAgICAgYWRkcmVzcyBmcm9tLFxuICAgICAgICBhZGRyZXNzIHRvLFxuICAgICAgICB1aW50MjU2IHRva2VuSWRcbiAgICApIHB1YmxpYyB2aXJ0dWFsIG92ZXJyaWRlIHtcbiAgICAgICAgc2FmZVRyYW5zZmVyRnJvbShmcm9tLCB0bywgdG9rZW5JZCwgXCJcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBTZWUge0lFUkM3MjEtc2FmZVRyYW5zZmVyRnJvbX0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FmZVRyYW5zZmVyRnJvbShcbiAgICAgICAgYWRkcmVzcyBmcm9tLFxuICAgICAgICBhZGRyZXNzIHRvLFxuICAgICAgICB1aW50MjU2IHRva2VuSWQsXG4gICAgICAgIGJ5dGVzIG1lbW9yeSBfZGF0YVxuICAgICkgcHVibGljIHZpcnR1YWwgb3ZlcnJpZGUge1xuICAgICAgICByZXF1aXJlKFxuICAgICAgICAgICAgX2lzQXBwcm92ZWRPck93bmVyKF9tc2dTZW5kZXIoKSwgdG9rZW5JZCksXG4gICAgICAgICAgICBcIkVSQzcyMTogdHJhbnNmZXIgY2FsbGVyIGlzIG5vdCBvd25lciBub3IgYXBwcm92ZWRcIlxuICAgICAgICApO1xuICAgICAgICBfc2FmZVRyYW5zZmVyKGZyb20sIHRvLCB0b2tlbklkLCBfZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBTYWZlbHkgdHJhbnNmZXJzICd0b2tlbklkJyB0b2tlbiBmcm9tICdmcm9tJyB0byAndG8nLCBjaGVja2luZyBmaXJzdCB0aGF0IGNvbnRyYWN0IHJlY2lwaWVudHNcbiAgICAgKiBhcmUgYXdhcmUgb2YgdGhlIEVSQzcyMSBwcm90b2NvbCB0byBwcmV2ZW50IHRva2VucyBmcm9tIGJlaW5nIGZvcmV2ZXIgbG9ja2VkLlxuICAgICAqXG4gICAgICogJ19kYXRhJyBpcyBhZGRpdGlvbmFsIGRhdGEsIGl0IGhhcyBubyBzcGVjaWZpZWQgZm9ybWF0IGFuZCBpdCBpcyBzZW50IGluIGNhbGwgdG8gJ3RvJy5cbiAgICAgKlxuICAgICAqIFRoaXMgaW50ZXJuYWwgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byB7c2FmZVRyYW5zZmVyRnJvbX0sIGFuZCBjYW4gYmUgdXNlZCB0byBlLmcuXG4gICAgICogaW1wbGVtZW50IGFsdGVybmF0aXZlIG1lY2hhbmlzbXMgdG8gcGVyZm9ybSB0b2tlbiB0cmFuc2Zlciwgc3VjaCBhcyBzaWduYXR1cmUtYmFzZWQuXG4gICAgICpcbiAgICAgKiBSZXF1aXJlbWVudHM6XG4gICAgICpcbiAgICAgKiAtICdmcm9tJyBjYW5ub3QgYmUgdGhlIHplcm8gYWRkcmVzcy5cbiAgICAgKiAtICd0bycgY2Fubm90IGJlIHRoZSB6ZXJvIGFkZHJlc3MuXG4gICAgICogLSAndG9rZW5JZCcgdG9rZW4gbXVzdCBleGlzdCBhbmQgYmUgb3duZWQgYnkgJ2Zyb20nLlxuICAgICAqIC0gSWYgJ3RvJyByZWZlcnMgdG8gYSBzbWFydCBjb250cmFjdCwgaXQgbXVzdCBpbXBsZW1lbnQge0lFUkM3MjFSZWNlaXZlci1vbkVSQzcyMVJlY2VpdmVkfSwgd2hpY2ggaXMgY2FsbGVkIHVwb24gYSBzYWZlIHRyYW5zZmVyLlxuICAgICAqXG4gICAgICogRW1pdHMgYSB7VHJhbnNmZXJ9IGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9zYWZlVHJhbnNmZXIoXG4gICAgICAgIGFkZHJlc3MgZnJvbSxcbiAgICAgICAgYWRkcmVzcyB0byxcbiAgICAgICAgdWludDI1NiB0b2tlbklkLFxuICAgICAgICBieXRlcyBtZW1vcnkgX2RhdGFcbiAgICApIGludGVybmFsIHZpcnR1YWwge1xuICAgICAgICBfdHJhbnNmZXIoZnJvbSwgdG8sIHRva2VuSWQpO1xuICAgICAgICByZXF1aXJlKFxuICAgICAgICAgICAgX2NoZWNrT25FUkM3MjFSZWNlaXZlZChmcm9tLCB0bywgdG9rZW5JZCwgX2RhdGEpLFxuICAgICAgICAgICAgXCJFUkM3MjE6IHRyYW5zZmVyIHRvIG5vbiBFUkM3MjFSZWNlaXZlciBpbXBsZW1lbnRlclwiXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBSZXR1cm5zIHdoZXRoZXIgJ3Rva2VuSWQnIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIFRva2VucyBjYW4gYmUgbWFuYWdlZCBieSB0aGVpciBvd25lciBvciBhcHByb3ZlZCBhY2NvdW50cyB2aWEge2FwcHJvdmV9IG9yIHtzZXRBcHByb3ZhbEZvckFsbH0uXG4gICAgICpcbiAgICAgKiBUb2tlbnMgc3RhcnQgZXhpc3Rpbmcgd2hlbiB0aGV5IGFyZSBtaW50ZWQgKCdfbWludCcpLFxuICAgICAqIGFuZCBzdG9wIGV4aXN0aW5nIHdoZW4gdGhleSBhcmUgYnVybmVkICgnX2J1cm4nKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZXhpc3RzKHVpbnQyNTYgdG9rZW5JZCkgaW50ZXJuYWwgdmlldyB2aXJ0dWFsIHJldHVybnMgKGJvb2wpIHtcbiAgICAgICAgcmV0dXJuIF9vd25lcnNbdG9rZW5JZF0gIT0gYWRkcmVzcygwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFJldHVybnMgd2hldGhlciAnc3BlbmRlcicgaXMgYWxsb3dlZCB0byBtYW5hZ2UgJ3Rva2VuSWQnLlxuICAgICAqXG4gICAgICogUmVxdWlyZW1lbnRzOlxuICAgICAqXG4gICAgICogLSAndG9rZW5JZCcgbXVzdCBleGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaXNBcHByb3ZlZE9yT3duZXIoYWRkcmVzcyBzcGVuZGVyLCB1aW50MjU2IHRva2VuSWQpXG4gICAgICAgIGludGVybmFsXG4gICAgICAgIHZpZXdcbiAgICAgICAgdmlydHVhbFxuICAgICAgICByZXR1cm5zIChib29sKVxuICAgIHtcbiAgICAgICAgcmVxdWlyZShcbiAgICAgICAgICAgIF9leGlzdHModG9rZW5JZCksXG4gICAgICAgICAgICBcIkVSQzcyMTogb3BlcmF0b3IgcXVlcnkgZm9yIG5vbmV4aXN0ZW50IHRva2VuXCJcbiAgICAgICAgKTtcbiAgICAgICAgYWRkcmVzcyBvd25lciA9IEVSQzcyMS5vd25lck9mKHRva2VuSWQpO1xuICAgICAgICByZXR1cm4gKHNwZW5kZXIgPT0gb3duZXIgfHxcbiAgICAgICAgICAgIGlzQXBwcm92ZWRGb3JBbGwob3duZXIsIHNwZW5kZXIpIHx8XG4gICAgICAgICAgICBnZXRBcHByb3ZlZCh0b2tlbklkKSA9PSBzcGVuZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFNhZmVseSBtaW50cyAndG9rZW5JZCcgYW5kIHRyYW5zZmVycyBpdCB0byAndG8nLlxuICAgICAqXG4gICAgICogUmVxdWlyZW1lbnRzOlxuICAgICAqXG4gICAgICogLSAndG9rZW5JZCcgbXVzdCBub3QgZXhpc3QuXG4gICAgICogLSBJZiAndG8nIHJlZmVycyB0byBhIHNtYXJ0IGNvbnRyYWN0LCBpdCBtdXN0IGltcGxlbWVudCB7SUVSQzcyMVJlY2VpdmVyLW9uRVJDNzIxUmVjZWl2ZWR9LCB3aGljaCBpcyBjYWxsZWQgdXBvbiBhIHNhZmUgdHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBFbWl0cyBhIHtUcmFuc2Zlcn0gZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3NhZmVNaW50KGFkZHJlc3MgdG8sIHVpbnQyNTYgdG9rZW5JZCkgaW50ZXJuYWwgdmlydHVhbCB7XG4gICAgICAgIF9zYWZlTWludCh0bywgdG9rZW5JZCwgXCJcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBTYW1lIGFzIHt4cmVmLUVSQzcyMS1fc2FmZU1pbnQtYWRkcmVzcy11aW50MjU2LX1bJ19zYWZlTWludCddLCB3aXRoIGFuIGFkZGl0aW9uYWwgJ2RhdGEnIHBhcmFtZXRlciB3aGljaCBpc1xuICAgICAqIGZvcndhcmRlZCBpbiB7SUVSQzcyMVJlY2VpdmVyLW9uRVJDNzIxUmVjZWl2ZWR9IHRvIGNvbnRyYWN0IHJlY2lwaWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3NhZmVNaW50KFxuICAgICAgICBhZGRyZXNzIHRvLFxuICAgICAgICB1aW50MjU2IHRva2VuSWQsXG4gICAgICAgIGJ5dGVzIG1lbW9yeSBfZGF0YVxuICAgICkgaW50ZXJuYWwgdmlydHVhbCB7XG4gICAgICAgIF9taW50KHRvLCB0b2tlbklkKTtcbiAgICAgICAgcmVxdWlyZShcbiAgICAgICAgICAgIF9jaGVja09uRVJDNzIxUmVjZWl2ZWQoYWRkcmVzcygwKSwgdG8sIHRva2VuSWQsIF9kYXRhKSxcbiAgICAgICAgICAgIFwiRVJDNzIxOiB0cmFuc2ZlciB0byBub24gRVJDNzIxUmVjZWl2ZXIgaW1wbGVtZW50ZXJcIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgTWludHMgJ3Rva2VuSWQnIGFuZCB0cmFuc2ZlcnMgaXQgdG8gJ3RvJy5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IFVzYWdlIG9mIHRoaXMgbWV0aG9kIGlzIGRpc2NvdXJhZ2VkLCB1c2Uge19zYWZlTWludH0gd2hlbmV2ZXIgcG9zc2libGVcbiAgICAgKlxuICAgICAqIFJlcXVpcmVtZW50czpcbiAgICAgKlxuICAgICAqIC0gJ3Rva2VuSWQnIG11c3Qgbm90IGV4aXN0LlxuICAgICAqIC0gJ3RvJyBjYW5ub3QgYmUgdGhlIHplcm8gYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEVtaXRzIGEge1RyYW5zZmVyfSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfbWludChhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpIGludGVybmFsIHZpcnR1YWwge1xuICAgICAgICByZXF1aXJlKHRvICE9IGFkZHJlc3MoMCksIFwiRVJDNzIxOiBtaW50IHRvIHRoZSB6ZXJvIGFkZHJlc3NcIik7XG4gICAgICAgIHJlcXVpcmUoIV9leGlzdHModG9rZW5JZCksIFwiRVJDNzIxOiB0b2tlbiBhbHJlYWR5IG1pbnRlZFwiKTtcblxuICAgICAgICBfYmVmb3JlVG9rZW5UcmFuc2ZlcihhZGRyZXNzKDApLCB0bywgdG9rZW5JZCk7XG5cbiAgICAgICAgX2JhbGFuY2VzW3RvXSArPSAxO1xuICAgICAgICBfb3duZXJzW3Rva2VuSWRdID0gdG87XG5cbiAgICAgICAgZW1pdCBUcmFuc2ZlcihhZGRyZXNzKDApLCB0bywgdG9rZW5JZCk7XG5cbiAgICAgICAgX2FmdGVyVG9rZW5UcmFuc2ZlcihhZGRyZXNzKDApLCB0bywgdG9rZW5JZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBEZXN0cm95cyAndG9rZW5JZCcuXG4gICAgICogVGhlIGFwcHJvdmFsIGlzIGNsZWFyZWQgd2hlbiB0aGUgdG9rZW4gaXMgYnVybmVkLlxuICAgICAqXG4gICAgICogUmVxdWlyZW1lbnRzOlxuICAgICAqXG4gICAgICogLSAndG9rZW5JZCcgbXVzdCBleGlzdC5cbiAgICAgKlxuICAgICAqIEVtaXRzIGEge1RyYW5zZmVyfSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfYnVybih1aW50MjU2IHRva2VuSWQpIGludGVybmFsIHZpcnR1YWwge1xuICAgICAgICBhZGRyZXNzIG93bmVyID0gRVJDNzIxLm93bmVyT2YodG9rZW5JZCk7XG5cbiAgICAgICAgX2JlZm9yZVRva2VuVHJhbnNmZXIob3duZXIsIGFkZHJlc3MoMCksIHRva2VuSWQpO1xuXG4gICAgICAgIC8vIENsZWFyIGFwcHJvdmFsc1xuICAgICAgICBfYXBwcm92ZShhZGRyZXNzKDApLCB0b2tlbklkKTtcblxuICAgICAgICBfYmFsYW5jZXNbb3duZXJdIC09IDE7XG4gICAgICAgIGRlbGV0ZSBfb3duZXJzW3Rva2VuSWRdO1xuXG4gICAgICAgIGVtaXQgVHJhbnNmZXIob3duZXIsIGFkZHJlc3MoMCksIHRva2VuSWQpO1xuXG4gICAgICAgIF9hZnRlclRva2VuVHJhbnNmZXIob3duZXIsIGFkZHJlc3MoMCksIHRva2VuSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgVHJhbnNmZXJzICd0b2tlbklkJyBmcm9tICdmcm9tJyB0byAndG8nLlxuICAgICAqICBBcyBvcHBvc2VkIHRvIHt0cmFuc2ZlckZyb219LCB0aGlzIGltcG9zZXMgbm8gcmVzdHJpY3Rpb25zIG9uIG1zZy5zZW5kZXIuXG4gICAgICpcbiAgICAgKiBSZXF1aXJlbWVudHM6XG4gICAgICpcbiAgICAgKiAtICd0bycgY2Fubm90IGJlIHRoZSB6ZXJvIGFkZHJlc3MuXG4gICAgICogLSAndG9rZW5JZCcgdG9rZW4gbXVzdCBiZSBvd25lZCBieSAnZnJvbScuXG4gICAgICpcbiAgICAgKiBFbWl0cyBhIHtUcmFuc2Zlcn0gZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3RyYW5zZmVyKFxuICAgICAgICBhZGRyZXNzIGZyb20sXG4gICAgICAgIGFkZHJlc3MgdG8sXG4gICAgICAgIHVpbnQyNTYgdG9rZW5JZFxuICAgICkgaW50ZXJuYWwgdmlydHVhbCB7XG4gICAgICAgIHJlcXVpcmUoXG4gICAgICAgICAgICBFUkM3MjEub3duZXJPZih0b2tlbklkKSA9PSBmcm9tLFxuICAgICAgICAgICAgXCJFUkM3MjE6IHRyYW5zZmVyIGZyb20gaW5jb3JyZWN0IG93bmVyXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmVxdWlyZSh0byAhPSBhZGRyZXNzKDApLCBcIkVSQzcyMTogdHJhbnNmZXIgdG8gdGhlIHplcm8gYWRkcmVzc1wiKTtcblxuICAgICAgICBfYmVmb3JlVG9rZW5UcmFuc2Zlcihmcm9tLCB0bywgdG9rZW5JZCk7XG5cbiAgICAgICAgLy8gQ2xlYXIgYXBwcm92YWxzIGZyb20gdGhlIHByZXZpb3VzIG93bmVyXG4gICAgICAgIF9hcHByb3ZlKGFkZHJlc3MoMCksIHRva2VuSWQpO1xuXG4gICAgICAgIF9iYWxhbmNlc1tmcm9tXSAtPSAxO1xuICAgICAgICBfYmFsYW5jZXNbdG9dICs9IDE7XG4gICAgICAgIF9vd25lcnNbdG9rZW5JZF0gPSB0bztcblxuICAgICAgICBlbWl0IFRyYW5zZmVyKGZyb20sIHRvLCB0b2tlbklkKTtcblxuICAgICAgICBfYWZ0ZXJUb2tlblRyYW5zZmVyKGZyb20sIHRvLCB0b2tlbklkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IEFwcHJvdmUgJ3RvJyB0byBvcGVyYXRlIG9uICd0b2tlbklkJ1xuICAgICAqXG4gICAgICogRW1pdHMgYSB7QXBwcm92YWx9IGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9hcHByb3ZlKGFkZHJlc3MgdG8sIHVpbnQyNTYgdG9rZW5JZCkgaW50ZXJuYWwgdmlydHVhbCB7XG4gICAgICAgIF90b2tlbkFwcHJvdmFsc1t0b2tlbklkXSA9IHRvO1xuICAgICAgICBlbWl0IEFwcHJvdmFsKEVSQzcyMS5vd25lck9mKHRva2VuSWQpLCB0bywgdG9rZW5JZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBBcHByb3ZlICdvcGVyYXRvcicgdG8gb3BlcmF0ZSBvbiBhbGwgb2YgJ293bmVyJyB0b2tlbnNcbiAgICAgKlxuICAgICAqIEVtaXRzIGEge0FwcHJvdmFsRm9yQWxsfSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfc2V0QXBwcm92YWxGb3JBbGwoXG4gICAgICAgIGFkZHJlc3Mgb3duZXIsXG4gICAgICAgIGFkZHJlc3Mgb3BlcmF0b3IsXG4gICAgICAgIGJvb2wgYXBwcm92ZWRcbiAgICApIGludGVybmFsIHZpcnR1YWwge1xuICAgICAgICByZXF1aXJlKG93bmVyICE9IG9wZXJhdG9yLCBcIkVSQzcyMTogYXBwcm92ZSB0byBjYWxsZXJcIik7XG4gICAgICAgIF9vcGVyYXRvckFwcHJvdmFsc1tvd25lcl1bb3BlcmF0b3JdID0gYXBwcm92ZWQ7XG4gICAgICAgIGVtaXQgQXBwcm92YWxGb3JBbGwob3duZXIsIG9wZXJhdG9yLCBhcHByb3ZlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBJbnRlcm5hbCBmdW5jdGlvbiB0byBpbnZva2Uge0lFUkM3MjFSZWNlaXZlci1vbkVSQzcyMVJlY2VpdmVkfSBvbiBhIHRhcmdldCBhZGRyZXNzLlxuICAgICAqIFRoZSBjYWxsIGlzIG5vdCBleGVjdXRlZCBpZiB0aGUgdGFyZ2V0IGFkZHJlc3MgaXMgbm90IGEgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbSBhZGRyZXNzIHJlcHJlc2VudGluZyB0aGUgcHJldmlvdXMgb3duZXIgb2YgdGhlIGdpdmVuIHRva2VuIElEXG4gICAgICogQHBhcmFtIHRvIHRhcmdldCBhZGRyZXNzIHRoYXQgd2lsbCByZWNlaXZlIHRoZSB0b2tlbnNcbiAgICAgKiBAcGFyYW0gdG9rZW5JZCB1aW50MjU2IElEIG9mIHRoZSB0b2tlbiB0byBiZSB0cmFuc2ZlcnJlZFxuICAgICAqIEBwYXJhbSBfZGF0YSBieXRlcyBvcHRpb25hbCBkYXRhIHRvIHNlbmQgYWxvbmcgd2l0aCB0aGUgY2FsbFxuICAgICAqIEByZXR1cm4gYm9vbCB3aGV0aGVyIHRoZSBjYWxsIGNvcnJlY3RseSByZXR1cm5lZCB0aGUgZXhwZWN0ZWQgbWFnaWMgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfY2hlY2tPbkVSQzcyMVJlY2VpdmVkKFxuICAgICAgICBhZGRyZXNzIGZyb20sXG4gICAgICAgIGFkZHJlc3MgdG8sXG4gICAgICAgIHVpbnQyNTYgdG9rZW5JZCxcbiAgICAgICAgYnl0ZXMgbWVtb3J5IF9kYXRhXG4gICAgKSBwcml2YXRlIHJldHVybnMgKGJvb2wpIHtcbiAgICAgICAgaWYgKHRvLmlzQ29udHJhY3QoKSkge1xuICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICAgSUVSQzcyMVJlY2VpdmVyKHRvKS5vbkVSQzcyMVJlY2VpdmVkKFxuICAgICAgICAgICAgICAgICAgICBfbXNnU2VuZGVyKCksXG4gICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuSWQsXG4gICAgICAgICAgICAgICAgICAgIF9kYXRhXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJucyAoYnl0ZXM0IHJldHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWwgPT0gSUVSQzcyMVJlY2VpdmVyLm9uRVJDNzIxUmVjZWl2ZWQuc2VsZWN0b3I7XG4gICAgICAgICAgICB9IGNhdGNoIChieXRlcyBtZW1vcnkgcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYXNvbi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkVSQzcyMTogdHJhbnNmZXIgdG8gbm9uIEVSQzcyMVJlY2VpdmVyIGltcGxlbWVudGVyXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3NlbWJseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoYWRkKDMyLCByZWFzb24pLCBtbG9hZChyZWFzb24pKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IEhvb2sgdGhhdCBpcyBjYWxsZWQgYmVmb3JlIGFueSB0b2tlbiB0cmFuc2Zlci4gVGhpcyBpbmNsdWRlcyBtaW50aW5nXG4gICAgICogYW5kIGJ1cm5pbmcuXG4gICAgICpcbiAgICAgKiBDYWxsaW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIFdoZW4gJ2Zyb20nIGFuZCAndG8nIGFyZSBib3RoIG5vbi16ZXJvLCAnJ2Zyb20nJydzICd0b2tlbklkJyB3aWxsIGJlXG4gICAgICogdHJhbnNmZXJyZWQgdG8gJ3RvJy5cbiAgICAgKiAtIFdoZW4gJ2Zyb20nIGlzIHplcm8sICd0b2tlbklkJyB3aWxsIGJlIG1pbnRlZCBmb3IgJ3RvJy5cbiAgICAgKiAtIFdoZW4gJ3RvJyBpcyB6ZXJvLCAnJ2Zyb20nJydzICd0b2tlbklkJyB3aWxsIGJlIGJ1cm5lZC5cbiAgICAgKiAtICdmcm9tJyBhbmQgJ3RvJyBhcmUgbmV2ZXIgYm90aCB6ZXJvLlxuICAgICAqXG4gICAgICogVG8gbGVhcm4gbW9yZSBhYm91dCBob29rcywgaGVhZCB0byB4cmVmOlJPT1Q6ZXh0ZW5kaW5nLWNvbnRyYWN0cy5hZG9jI3VzaW5nLWhvb2tzW1VzaW5nIEhvb2tzXS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfYmVmb3JlVG9rZW5UcmFuc2ZlcihcbiAgICAgICAgYWRkcmVzcyBmcm9tLFxuICAgICAgICBhZGRyZXNzIHRvLFxuICAgICAgICB1aW50MjU2IHRva2VuSWRcbiAgICApIGludGVybmFsIHZpcnR1YWwge31cblxuICAgIC8qKlxuICAgICAqIEBkZXYgSG9vayB0aGF0IGlzIGNhbGxlZCBhZnRlciBhbnkgdHJhbnNmZXIgb2YgdG9rZW5zLiBUaGlzIGluY2x1ZGVzXG4gICAgICogbWludGluZyBhbmQgYnVybmluZy5cbiAgICAgKlxuICAgICAqIENhbGxpbmcgY29uZGl0aW9uczpcbiAgICAgKlxuICAgICAqIC0gd2hlbiAnZnJvbScgYW5kICd0bycgYXJlIGJvdGggbm9uLXplcm8uXG4gICAgICogLSAnZnJvbScgYW5kICd0bycgYXJlIG5ldmVyIGJvdGggemVyby5cbiAgICAgKlxuICAgICAqIFRvIGxlYXJuIG1vcmUgYWJvdXQgaG9va3MsIGhlYWQgdG8geHJlZjpST09UOmV4dGVuZGluZy1jb250cmFjdHMuYWRvYyN1c2luZy1ob29rc1tVc2luZyBIb29rc10uXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2FmdGVyVG9rZW5UcmFuc2ZlcihcbiAgICAgICAgYWRkcmVzcyBmcm9tLFxuICAgICAgICBhZGRyZXNzIHRvLFxuICAgICAgICB1aW50MjU2IHRva2VuSWRcbiAgICApIGludGVybmFsIHZpcnR1YWwge31cbn1cblxuLy8gRmlsZSBAb3BlbnplcHBlbGluL2NvbnRyYWN0cy9hY2Nlc3MvT3duYWJsZS5zb2xAdjQuNi4wXG5cbi8vIE9wZW5aZXBwZWxpbiBDb250cmFjdHMgdjQuNC4xIChhY2Nlc3MvT3duYWJsZS5zb2wpXG5cbnByYWdtYSBzb2xpZGl0eSBeMC44LjA7XG5cbi8qKlxuICogQGRldiBDb250cmFjdCBtb2R1bGUgd2hpY2ggcHJvdmlkZXMgYSBiYXNpYyBhY2Nlc3MgY29udHJvbCBtZWNoYW5pc20sIHdoZXJlXG4gKiB0aGVyZSBpcyBhbiBhY2NvdW50IChhbiBvd25lcikgdGhhdCBjYW4gYmUgZ3JhbnRlZCBleGNsdXNpdmUgYWNjZXNzIHRvXG4gKiBzcGVjaWZpYyBmdW5jdGlvbnMuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIG93bmVyIGFjY291bnQgd2lsbCBiZSB0aGUgb25lIHRoYXQgZGVwbG95cyB0aGUgY29udHJhY3QuIFRoaXNcbiAqIGNhbiBsYXRlciBiZSBjaGFuZ2VkIHdpdGgge3RyYW5zZmVyT3duZXJzaGlwfS5cbiAqXG4gKiBUaGlzIG1vZHVsZSBpcyB1c2VkIHRocm91Z2ggaW5oZXJpdGFuY2UuIEl0IHdpbGwgbWFrZSBhdmFpbGFibGUgdGhlIG1vZGlmaWVyXG4gKiAnb25seU93bmVyJywgd2hpY2ggY2FuIGJlIGFwcGxpZWQgdG8geW91ciBmdW5jdGlvbnMgdG8gcmVzdHJpY3QgdGhlaXIgdXNlIHRvXG4gKiB0aGUgb3duZXIuXG4gKi9cbmFic3RyYWN0IGNvbnRyYWN0IE93bmFibGUgaXMgQ29udGV4dCB7XG4gICAgYWRkcmVzcyBwcml2YXRlIF9vd25lcjtcblxuICAgIGV2ZW50IE93bmVyc2hpcFRyYW5zZmVycmVkKFxuICAgICAgICBhZGRyZXNzIGluZGV4ZWQgcHJldmlvdXNPd25lcixcbiAgICAgICAgYWRkcmVzcyBpbmRleGVkIG5ld093bmVyXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIEBkZXYgSW5pdGlhbGl6ZXMgdGhlIGNvbnRyYWN0IHNldHRpbmcgdGhlIGRlcGxveWVyIGFzIHRoZSBpbml0aWFsIG93bmVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBfdHJhbnNmZXJPd25lcnNoaXAoX21zZ1NlbmRlcigpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFJldHVybnMgdGhlIGFkZHJlc3Mgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3duZXIoKSBwdWJsaWMgdmlldyB2aXJ0dWFsIHJldHVybnMgKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9vd25lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFRocm93cyBpZiBjYWxsZWQgYnkgYW55IGFjY291bnQgb3RoZXIgdGhhbiB0aGUgb3duZXIuXG4gICAgICovXG4gICAgbW9kaWZpZXIgb25seU93bmVyKCkge1xuICAgICAgICByZXF1aXJlKG93bmVyKCkgPT0gX21zZ1NlbmRlcigpLCBcIk93bmFibGU6IGNhbGxlciBpcyBub3QgdGhlIG93bmVyXCIpO1xuICAgICAgICBfO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgTGVhdmVzIHRoZSBjb250cmFjdCB3aXRob3V0IG93bmVyLiBJdCB3aWxsIG5vdCBiZSBwb3NzaWJsZSB0byBjYWxsXG4gICAgICogJ29ubHlPd25lcicgZnVuY3Rpb25zIGFueW1vcmUuIENhbiBvbmx5IGJlIGNhbGxlZCBieSB0aGUgY3VycmVudCBvd25lci5cbiAgICAgKlxuICAgICAqIE5PVEU6IFJlbm91bmNpbmcgb3duZXJzaGlwIHdpbGwgbGVhdmUgdGhlIGNvbnRyYWN0IHdpdGhvdXQgYW4gb3duZXIsXG4gICAgICogdGhlcmVieSByZW1vdmluZyBhbnkgZnVuY3Rpb25hbGl0eSB0aGF0IGlzIG9ubHkgYXZhaWxhYmxlIHRvIHRoZSBvd25lci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW5vdW5jZU93bmVyc2hpcCgpIHB1YmxpYyB2aXJ0dWFsIG9ubHlPd25lciB7XG4gICAgICAgIF90cmFuc2Zlck93bmVyc2hpcChhZGRyZXNzKDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFRyYW5zZmVycyBvd25lcnNoaXAgb2YgdGhlIGNvbnRyYWN0IHRvIGEgbmV3IGFjY291bnQgKCduZXdPd25lcicpLlxuICAgICAqIENhbiBvbmx5IGJlIGNhbGxlZCBieSB0aGUgY3VycmVudCBvd25lci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zlck93bmVyc2hpcChhZGRyZXNzIG5ld093bmVyKSBwdWJsaWMgdmlydHVhbCBvbmx5T3duZXIge1xuICAgICAgICByZXF1aXJlKFxuICAgICAgICAgICAgbmV3T3duZXIgIT0gYWRkcmVzcygwKSxcbiAgICAgICAgICAgIFwiT3duYWJsZTogbmV3IG93bmVyIGlzIHRoZSB6ZXJvIGFkZHJlc3NcIlxuICAgICAgICApO1xuICAgICAgICBfdHJhbnNmZXJPd25lcnNoaXAobmV3T3duZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgVHJhbnNmZXJzIG93bmVyc2hpcCBvZiB0aGUgY29udHJhY3QgdG8gYSBuZXcgYWNjb3VudCAoJ25ld093bmVyJykuXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gd2l0aG91dCBhY2Nlc3MgcmVzdHJpY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3RyYW5zZmVyT3duZXJzaGlwKGFkZHJlc3MgbmV3T3duZXIpIGludGVybmFsIHZpcnR1YWwge1xuICAgICAgICBhZGRyZXNzIG9sZE93bmVyID0gX293bmVyO1xuICAgICAgICBfb3duZXIgPSBuZXdPd25lcjtcbiAgICAgICAgZW1pdCBPd25lcnNoaXBUcmFuc2ZlcnJlZChvbGRPd25lciwgbmV3T3duZXIpO1xuICAgIH1cbn1cblxuLy8gRmlsZSBAb3BlbnplcHBlbGluL2NvbnRyYWN0cy91dGlscy9jcnlwdG9ncmFwaHkvTWVya2xlUHJvb2Yuc29sQHY0LjYuMFxuXG4vLyBPcGVuWmVwcGVsaW4gQ29udHJhY3RzIChsYXN0IHVwZGF0ZWQgdjQuNi4wKSAodXRpbHMvY3J5cHRvZ3JhcGh5L01lcmtsZVByb29mLnNvbClcblxucHJhZ21hIHNvbGlkaXR5IF4wLjguMDtcblxuLyoqXG4gKiBAZGV2IFRoZXNlIGZ1bmN0aW9ucyBkZWFsIHdpdGggdmVyaWZpY2F0aW9uIG9mIE1lcmtsZSBUcmVlcyBwcm9vZnMuXG4gKlxuICogVGhlIHByb29mcyBjYW4gYmUgZ2VuZXJhdGVkIHVzaW5nIHRoZSBKYXZhU2NyaXB0IGxpYnJhcnlcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWd1ZWxtb3RhL21lcmtsZXRyZWVqc1ttZXJrbGV0cmVlanNdLlxuICogTm90ZTogdGhlIGhhc2hpbmcgYWxnb3JpdGhtIHNob3VsZCBiZSBrZWNjYWsyNTYgYW5kIHBhaXIgc29ydGluZyBzaG91bGQgYmUgZW5hYmxlZC5cbiAqXG4gKiBTZWUgJ3Rlc3QvdXRpbHMvY3J5cHRvZ3JhcGh5L01lcmtsZVByb29mLnRlc3QuanMnIGZvciBzb21lIGV4YW1wbGVzLlxuICpcbiAqIFdBUk5JTkc6IFlvdSBzaG91bGQgYXZvaWQgdXNpbmcgbGVhZiB2YWx1ZXMgdGhhdCBhcmUgNjQgYnl0ZXMgbG9uZyBwcmlvciB0b1xuICogaGFzaGluZywgb3IgdXNlIGEgaGFzaCBmdW5jdGlvbiBvdGhlciB0aGFuIGtlY2NhazI1NiBmb3IgaGFzaGluZyBsZWF2ZXMuXG4gKiBUaGlzIGlzIGJlY2F1c2UgdGhlIGNvbmNhdGVuYXRpb24gb2YgYSBzb3J0ZWQgcGFpciBvZiBpbnRlcm5hbCBub2RlcyBpblxuICogdGhlIG1lcmtsZSB0cmVlIGNvdWxkIGJlIHJlaW50ZXJwcmV0ZWQgYXMgYSBsZWFmIHZhbHVlLlxuICovXG5saWJyYXJ5IE1lcmtsZVByb29mIHtcbiAgICAvKipcbiAgICAgKiBAZGV2IFJldHVybnMgdHJ1ZSBpZiBhICdsZWFmJyBjYW4gYmUgcHJvdmVkIHRvIGJlIGEgcGFydCBvZiBhIE1lcmtsZSB0cmVlXG4gICAgICogZGVmaW5lZCBieSAncm9vdCcuIEZvciB0aGlzLCBhICdwcm9vZicgbXVzdCBiZSBwcm92aWRlZCwgY29udGFpbmluZ1xuICAgICAqIHNpYmxpbmcgaGFzaGVzIG9uIHRoZSBicmFuY2ggZnJvbSB0aGUgbGVhZiB0byB0aGUgcm9vdCBvZiB0aGUgdHJlZS4gRWFjaFxuICAgICAqIHBhaXIgb2YgbGVhdmVzIGFuZCBlYWNoIHBhaXIgb2YgcHJlLWltYWdlcyBhcmUgYXNzdW1lZCB0byBiZSBzb3J0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KFxuICAgICAgICBieXRlczMyW10gbWVtb3J5IHByb29mLFxuICAgICAgICBieXRlczMyIHJvb3QsXG4gICAgICAgIGJ5dGVzMzIgbGVhZlxuICAgICkgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChib29sKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUHJvb2YocHJvb2YsIGxlYWYpID09IHJvb3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBSZXR1cm5zIHRoZSByZWJ1aWx0IGhhc2ggb2J0YWluZWQgYnkgdHJhdmVyc2luZyBhIE1lcmtsZSB0cmVlIHVwXG4gICAgICogZnJvbSAnbGVhZicgdXNpbmcgJ3Byb29mJy4gQSAncHJvb2YnIGlzIHZhbGlkIGlmIGFuZCBvbmx5IGlmIHRoZSByZWJ1aWx0XG4gICAgICogaGFzaCBtYXRjaGVzIHRoZSByb290IG9mIHRoZSB0cmVlLiBXaGVuIHByb2Nlc3NpbmcgdGhlIHByb29mLCB0aGUgcGFpcnNcbiAgICAgKiBvZiBsZWFmcyAmIHByZS1pbWFnZXMgYXJlIGFzc3VtZWQgdG8gYmUgc29ydGVkLlxuICAgICAqXG4gICAgICogX0F2YWlsYWJsZSBzaW5jZSB2NC40Ll9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzUHJvb2YoYnl0ZXMzMltdIG1lbW9yeSBwcm9vZiwgYnl0ZXMzMiBsZWFmKVxuICAgICAgICBpbnRlcm5hbFxuICAgICAgICBwdXJlXG4gICAgICAgIHJldHVybnMgKGJ5dGVzMzIpXG4gICAge1xuICAgICAgICBieXRlczMyIGNvbXB1dGVkSGFzaCA9IGxlYWY7XG4gICAgICAgIGZvciAodWludDI1NiBpID0gMDsgaSA8IHByb29mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBieXRlczMyIHByb29mRWxlbWVudCA9IHByb29mW2ldO1xuICAgICAgICAgICAgaWYgKGNvbXB1dGVkSGFzaCA8PSBwcm9vZkVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBIYXNoKGN1cnJlbnQgY29tcHV0ZWQgaGFzaCArIGN1cnJlbnQgZWxlbWVudCBvZiB0aGUgcHJvb2YpXG4gICAgICAgICAgICAgICAgY29tcHV0ZWRIYXNoID0gX2VmZmljaWVudEhhc2goY29tcHV0ZWRIYXNoLCBwcm9vZkVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBIYXNoKGN1cnJlbnQgZWxlbWVudCBvZiB0aGUgcHJvb2YgKyBjdXJyZW50IGNvbXB1dGVkIGhhc2gpXG4gICAgICAgICAgICAgICAgY29tcHV0ZWRIYXNoID0gX2VmZmljaWVudEhhc2gocHJvb2ZFbGVtZW50LCBjb21wdXRlZEhhc2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wdXRlZEhhc2g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2VmZmljaWVudEhhc2goYnl0ZXMzMiBhLCBieXRlczMyIGIpXG4gICAgICAgIHByaXZhdGVcbiAgICAgICAgcHVyZVxuICAgICAgICByZXR1cm5zIChieXRlczMyIHZhbHVlKVxuICAgIHtcbiAgICAgICAgYXNzZW1ibHkge1xuICAgICAgICAgICAgbXN0b3JlKDB4MDAsIGEpXG4gICAgICAgICAgICBtc3RvcmUoMHgyMCwgYilcbiAgICAgICAgICAgIHZhbHVlIDo9IGtlY2NhazI1NigweDAwLCAweDQwKVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBGaWxlIEBvcGVuemVwcGVsaW4vY29udHJhY3RzL3Rva2VuL0VSQzcyMS9leHRlbnNpb25zL0VSQzcyMVVSSVN0b3JhZ2Uuc29sQHY0LjYuMFxuXG4vLyBPcGVuWmVwcGVsaW4gQ29udHJhY3RzIHY0LjQuMSAodG9rZW4vRVJDNzIxL2V4dGVuc2lvbnMvRVJDNzIxVVJJU3RvcmFnZS5zb2wpXG5cbnByYWdtYSBzb2xpZGl0eSBeMC44LjA7XG5cbi8qKlxuICogQGRldiBFUkM3MjEgdG9rZW4gd2l0aCBzdG9yYWdlIGJhc2VkIHRva2VuIFVSSSBtYW5hZ2VtZW50LlxuICovXG5hYnN0cmFjdCBjb250cmFjdCBFUkM3MjFVUklTdG9yYWdlIGlzIEVSQzcyMSB7XG4gICAgdXNpbmcgU3RyaW5ncyBmb3IgdWludDI1NjtcblxuICAgIC8vIE9wdGlvbmFsIG1hcHBpbmcgZm9yIHRva2VuIFVSSXNcbiAgICBtYXBwaW5nKHVpbnQyNTYgPT4gc3RyaW5nKSBwcml2YXRlIF90b2tlblVSSXM7XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFNlZSB7SUVSQzcyMU1ldGFkYXRhLXRva2VuVVJJfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b2tlblVSSSh1aW50MjU2IHRva2VuSWQpXG4gICAgICAgIHB1YmxpY1xuICAgICAgICB2aWV3XG4gICAgICAgIHZpcnR1YWxcbiAgICAgICAgb3ZlcnJpZGVcbiAgICAgICAgcmV0dXJucyAoc3RyaW5nIG1lbW9yeSlcbiAgICB7XG4gICAgICAgIHJlcXVpcmUoXG4gICAgICAgICAgICBfZXhpc3RzKHRva2VuSWQpLFxuICAgICAgICAgICAgXCJFUkM3MjFVUklTdG9yYWdlOiBVUkkgcXVlcnkgZm9yIG5vbmV4aXN0ZW50IHRva2VuXCJcbiAgICAgICAgKTtcblxuICAgICAgICBzdHJpbmcgbWVtb3J5IF90b2tlblVSSSA9IF90b2tlblVSSXNbdG9rZW5JZF07XG4gICAgICAgIHN0cmluZyBtZW1vcnkgYmFzZSA9IF9iYXNlVVJJKCk7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gYmFzZSBVUkksIHJldHVybiB0aGUgdG9rZW4gVVJJLlxuICAgICAgICBpZiAoYnl0ZXMoYmFzZSkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfdG9rZW5VUkk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYm90aCBhcmUgc2V0LCBjb25jYXRlbmF0ZSB0aGUgYmFzZVVSSSBhbmQgdG9rZW5VUkkgKHZpYSBhYmkuZW5jb2RlUGFja2VkKS5cbiAgICAgICAgaWYgKGJ5dGVzKF90b2tlblVSSSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZyhhYmkuZW5jb2RlUGFja2VkKGJhc2UsIF90b2tlblVSSSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLnRva2VuVVJJKHRva2VuSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgU2V0cyAnX3Rva2VuVVJJJyBhcyB0aGUgdG9rZW5VUkkgb2YgJ3Rva2VuSWQnLlxuICAgICAqXG4gICAgICogUmVxdWlyZW1lbnRzOlxuICAgICAqXG4gICAgICogLSAndG9rZW5JZCcgbXVzdCBleGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfc2V0VG9rZW5VUkkodWludDI1NiB0b2tlbklkLCBzdHJpbmcgbWVtb3J5IF90b2tlblVSSSlcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgdmlydHVhbFxuICAgIHtcbiAgICAgICAgcmVxdWlyZShcbiAgICAgICAgICAgIF9leGlzdHModG9rZW5JZCksXG4gICAgICAgICAgICBcIkVSQzcyMVVSSVN0b3JhZ2U6IFVSSSBzZXQgb2Ygbm9uZXhpc3RlbnQgdG9rZW5cIlxuICAgICAgICApO1xuICAgICAgICBfdG9rZW5VUklzW3Rva2VuSWRdID0gX3Rva2VuVVJJO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgRGVzdHJveXMgJ3Rva2VuSWQnLlxuICAgICAqIFRoZSBhcHByb3ZhbCBpcyBjbGVhcmVkIHdoZW4gdGhlIHRva2VuIGlzIGJ1cm5lZC5cbiAgICAgKlxuICAgICAqIFJlcXVpcmVtZW50czpcbiAgICAgKlxuICAgICAqIC0gJ3Rva2VuSWQnIG11c3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBFbWl0cyBhIHtUcmFuc2Zlcn0gZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2J1cm4odWludDI1NiB0b2tlbklkKSBpbnRlcm5hbCB2aXJ0dWFsIG92ZXJyaWRlIHtcbiAgICAgICAgc3VwZXIuX2J1cm4odG9rZW5JZCk7XG5cbiAgICAgICAgaWYgKGJ5dGVzKF90b2tlblVSSXNbdG9rZW5JZF0pLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgX3Rva2VuVVJJc1t0b2tlbklkXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gRmlsZSBAb3BlbnplcHBlbGluL2NvbnRyYWN0cy91dGlscy9Db3VudGVycy5zb2xAdjQuNi4wXG5cbi8vIE9wZW5aZXBwZWxpbiBDb250cmFjdHMgdjQuNC4xICh1dGlscy9Db3VudGVycy5zb2wpXG5cbnByYWdtYSBzb2xpZGl0eSBeMC44LjA7XG5cbi8qKlxuICogQHRpdGxlIENvdW50ZXJzXG4gKiBAYXV0aG9yIE1hdHQgQ29uZG9uIChAc2hydWdzKVxuICogQGRldiBQcm92aWRlcyBjb3VudGVycyB0aGF0IGNhbiBvbmx5IGJlIGluY3JlbWVudGVkLCBkZWNyZW1lbnRlZCBvciByZXNldC4gVGhpcyBjYW4gYmUgdXNlZCBlLmcuIHRvIHRyYWNrIHRoZSBudW1iZXJcbiAqIG9mIGVsZW1lbnRzIGluIGEgbWFwcGluZywgaXNzdWluZyBFUkM3MjEgaWRzLCBvciBjb3VudGluZyByZXF1ZXN0IGlkcy5cbiAqXG4gKiBJbmNsdWRlIHdpdGggJ3VzaW5nIENvdW50ZXJzIGZvciBDb3VudGVycy5Db3VudGVyOydcbiAqL1xubGlicmFyeSBDb3VudGVycyB7XG4gICAgc3RydWN0IENvdW50ZXIge1xuICAgICAgICAvLyBUaGlzIHZhcmlhYmxlIHNob3VsZCBuZXZlciBiZSBkaXJlY3RseSBhY2Nlc3NlZCBieSB1c2VycyBvZiB0aGUgbGlicmFyeTogaW50ZXJhY3Rpb25zIG11c3QgYmUgcmVzdHJpY3RlZCB0b1xuICAgICAgICAvLyB0aGUgbGlicmFyeSdzIGZ1bmN0aW9uLiBBcyBvZiBTb2xpZGl0eSB2MC41LjIsIHRoaXMgY2Fubm90IGJlIGVuZm9yY2VkLCB0aG91Z2ggdGhlcmUgaXMgYSBwcm9wb3NhbCB0byBhZGRcbiAgICAgICAgLy8gdGhpcyBmZWF0dXJlOiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3NvbGlkaXR5L2lzc3Vlcy80NjM3XG4gICAgICAgIHVpbnQyNTYgX3ZhbHVlOyAvLyBkZWZhdWx0OiAwXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudChDb3VudGVyIHN0b3JhZ2UgY291bnRlcikgaW50ZXJuYWwgdmlldyByZXR1cm5zICh1aW50MjU2KSB7XG4gICAgICAgIHJldHVybiBjb3VudGVyLl92YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmNyZW1lbnQoQ291bnRlciBzdG9yYWdlIGNvdW50ZXIpIGludGVybmFsIHtcbiAgICAgICAgdW5jaGVja2VkIHtcbiAgICAgICAgICAgIGNvdW50ZXIuX3ZhbHVlICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWNyZW1lbnQoQ291bnRlciBzdG9yYWdlIGNvdW50ZXIpIGludGVybmFsIHtcbiAgICAgICAgdWludDI1NiB2YWx1ZSA9IGNvdW50ZXIuX3ZhbHVlO1xuICAgICAgICByZXF1aXJlKHZhbHVlID4gMCwgXCJDb3VudGVyOiBkZWNyZW1lbnQgb3ZlcmZsb3dcIik7XG4gICAgICAgIHVuY2hlY2tlZCB7XG4gICAgICAgICAgICBjb3VudGVyLl92YWx1ZSA9IHZhbHVlIC0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0KENvdW50ZXIgc3RvcmFnZSBjb3VudGVyKSBpbnRlcm5hbCB7XG4gICAgICAgIGNvdW50ZXIuX3ZhbHVlID0gMDtcbiAgICB9XG59XG5cbi8vIEZpbGUgQG9wZW56ZXBwZWxpbi9jb250cmFjdHMvdXRpbHMvY3J5cHRvZ3JhcGh5L0VDRFNBLnNvbEB2NC42LjBcblxuLy8gT3BlblplcHBlbGluIENvbnRyYWN0cyAobGFzdCB1cGRhdGVkIHY0LjUuMCkgKHV0aWxzL2NyeXB0b2dyYXBoeS9FQ0RTQS5zb2wpXG5cbnByYWdtYSBzb2xpZGl0eSBeMC44LjA7XG5cbi8qKlxuICogQGRldiBFbGxpcHRpYyBDdXJ2ZSBEaWdpdGFsIFNpZ25hdHVyZSBBbGdvcml0aG0gKEVDRFNBKSBvcGVyYXRpb25zLlxuICpcbiAqIFRoZXNlIGZ1bmN0aW9ucyBjYW4gYmUgdXNlZCB0byB2ZXJpZnkgdGhhdCBhIG1lc3NhZ2Ugd2FzIHNpZ25lZCBieSB0aGUgaG9sZGVyXG4gKiBvZiB0aGUgcHJpdmF0ZSBrZXlzIG9mIGEgZ2l2ZW4gYWRkcmVzcy5cbiAqL1xubGlicmFyeSBFQ0RTQSB7XG4gICAgZW51bSBSZWNvdmVyRXJyb3Ige1xuICAgICAgICBOb0Vycm9yLFxuICAgICAgICBJbnZhbGlkU2lnbmF0dXJlLFxuICAgICAgICBJbnZhbGlkU2lnbmF0dXJlTGVuZ3RoLFxuICAgICAgICBJbnZhbGlkU2lnbmF0dXJlUyxcbiAgICAgICAgSW52YWxpZFNpZ25hdHVyZVZcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdGhyb3dFcnJvcihSZWNvdmVyRXJyb3IgZXJyb3IpIHByaXZhdGUgcHVyZSB7XG4gICAgICAgIGlmIChlcnJvciA9PSBSZWNvdmVyRXJyb3IuTm9FcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBubyBlcnJvcjogZG8gbm90aGluZ1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yID09IFJlY292ZXJFcnJvci5JbnZhbGlkU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICByZXZlcnQoXCJFQ0RTQTogaW52YWxpZCBzaWduYXR1cmVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgPT0gUmVjb3ZlckVycm9yLkludmFsaWRTaWduYXR1cmVMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldmVydChcIkVDRFNBOiBpbnZhbGlkIHNpZ25hdHVyZSBsZW5ndGhcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgPT0gUmVjb3ZlckVycm9yLkludmFsaWRTaWduYXR1cmVTKSB7XG4gICAgICAgICAgICByZXZlcnQoXCJFQ0RTQTogaW52YWxpZCBzaWduYXR1cmUgJ3MnIHZhbHVlXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yID09IFJlY292ZXJFcnJvci5JbnZhbGlkU2lnbmF0dXJlVikge1xuICAgICAgICAgICAgcmV2ZXJ0KFwiRUNEU0E6IGludmFsaWQgc2lnbmF0dXJlICd2JyB2YWx1ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgUmV0dXJucyB0aGUgYWRkcmVzcyB0aGF0IHNpZ25lZCBhIGhhc2hlZCBtZXNzYWdlICgnaGFzaCcpIHdpdGhcbiAgICAgKiAnc2lnbmF0dXJlJyBvciBlcnJvciBzdHJpbmcuIFRoaXMgYWRkcmVzcyBjYW4gdGhlbiBiZSB1c2VkIGZvciB2ZXJpZmljYXRpb24gcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBUaGUgJ2VjcmVjb3ZlcicgRVZNIG9wY29kZSBhbGxvd3MgZm9yIG1hbGxlYWJsZSAobm9uLXVuaXF1ZSkgc2lnbmF0dXJlczpcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJlamVjdHMgdGhlbSBieSByZXF1aXJpbmcgdGhlICdzJyB2YWx1ZSB0byBiZSBpbiB0aGUgbG93ZXJcbiAgICAgKiBoYWxmIG9yZGVyLCBhbmQgdGhlICd2JyB2YWx1ZSB0byBiZSBlaXRoZXIgMjcgb3IgMjguXG4gICAgICpcbiAgICAgKiBJTVBPUlRBTlQ6ICdoYXNoJyBfbXVzdF8gYmUgdGhlIHJlc3VsdCBvZiBhIGhhc2ggb3BlcmF0aW9uIGZvciB0aGVcbiAgICAgKiB2ZXJpZmljYXRpb24gdG8gYmUgc2VjdXJlOiBpdCBpcyBwb3NzaWJsZSB0byBjcmFmdCBzaWduYXR1cmVzIHRoYXRcbiAgICAgKiByZWNvdmVyIHRvIGFyYml0cmFyeSBhZGRyZXNzZXMgZm9yIG5vbi1oYXNoZWQgZGF0YS4gQSBzYWZlIHdheSB0byBlbnN1cmVcbiAgICAgKiB0aGlzIGlzIGJ5IHJlY2VpdmluZyBhIGhhc2ggb2YgdGhlIG9yaWdpbmFsIG1lc3NhZ2UgKHdoaWNoIG1heSBvdGhlcndpc2VcbiAgICAgKiBiZSB0b28gbG9uZyksIGFuZCB0aGVuIGNhbGxpbmcge3RvRXRoU2lnbmVkTWVzc2FnZUhhc2h9IG9uIGl0LlxuICAgICAqXG4gICAgICogRG9jdW1lbnRhdGlvbiBmb3Igc2lnbmF0dXJlIGdlbmVyYXRpb246XG4gICAgICogLSB3aXRoIGh0dHBzOi8vd2ViM2pzLnJlYWR0aGVkb2NzLmlvL2VuL3YxLjMuNC93ZWIzLWV0aC1hY2NvdW50cy5odG1sI3NpZ25bV2ViMy5qc11cbiAgICAgKiAtIHdpdGggaHR0cHM6Ly9kb2NzLmV0aGVycy5pby92NS9hcGkvc2lnbmVyLyNTaWduZXItc2lnbk1lc3NhZ2VbZXRoZXJzXVxuICAgICAqXG4gICAgICogX0F2YWlsYWJsZSBzaW5jZSB2NC4zLl9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnlSZWNvdmVyKGJ5dGVzMzIgaGFzaCwgYnl0ZXMgbWVtb3J5IHNpZ25hdHVyZSlcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgcHVyZVxuICAgICAgICByZXR1cm5zIChhZGRyZXNzLCBSZWNvdmVyRXJyb3IpXG4gICAge1xuICAgICAgICAvLyBDaGVjayB0aGUgc2lnbmF0dXJlIGxlbmd0aFxuICAgICAgICAvLyAtIGNhc2UgNjU6IHIscyx2IHNpZ25hdHVyZSAoc3RhbmRhcmQpXG4gICAgICAgIC8vIC0gY2FzZSA2NDogcix2cyBzaWduYXR1cmUgKGNmIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMjA5OCkgX0F2YWlsYWJsZSBzaW5jZSB2NC4xLl9cbiAgICAgICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggPT0gNjUpIHtcbiAgICAgICAgICAgIGJ5dGVzMzIgcjtcbiAgICAgICAgICAgIGJ5dGVzMzIgcztcbiAgICAgICAgICAgIHVpbnQ4IHY7XG4gICAgICAgICAgICAvLyBlY3JlY292ZXIgdGFrZXMgdGhlIHNpZ25hdHVyZSBwYXJhbWV0ZXJzLCBhbmQgdGhlIG9ubHkgd2F5IHRvIGdldCB0aGVtXG4gICAgICAgICAgICAvLyBjdXJyZW50bHkgaXMgdG8gdXNlIGFzc2VtYmx5LlxuICAgICAgICAgICAgYXNzZW1ibHkge1xuICAgICAgICAgICAgICAgIHIgOj0gbWxvYWQoYWRkKHNpZ25hdHVyZSwgMHgyMCkpXG4gICAgICAgICAgICAgICAgcyA6PSBtbG9hZChhZGQoc2lnbmF0dXJlLCAweDQwKSlcbiAgICAgICAgICAgICAgICB2IDo9IGJ5dGUoMCwgbWxvYWQoYWRkKHNpZ25hdHVyZSwgMHg2MCkpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyeVJlY292ZXIoaGFzaCwgdiwgciwgcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlLmxlbmd0aCA9PSA2NCkge1xuICAgICAgICAgICAgYnl0ZXMzMiByO1xuICAgICAgICAgICAgYnl0ZXMzMiB2cztcbiAgICAgICAgICAgIC8vIGVjcmVjb3ZlciB0YWtlcyB0aGUgc2lnbmF0dXJlIHBhcmFtZXRlcnMsIGFuZCB0aGUgb25seSB3YXkgdG8gZ2V0IHRoZW1cbiAgICAgICAgICAgIC8vIGN1cnJlbnRseSBpcyB0byB1c2UgYXNzZW1ibHkuXG4gICAgICAgICAgICBhc3NlbWJseSB7XG4gICAgICAgICAgICAgICAgciA6PSBtbG9hZChhZGQoc2lnbmF0dXJlLCAweDIwKSlcbiAgICAgICAgICAgICAgICB2cyA6PSBtbG9hZChhZGQoc2lnbmF0dXJlLCAweDQwKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnlSZWNvdmVyKGhhc2gsIHIsIHZzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoYWRkcmVzcygwKSwgUmVjb3ZlckVycm9yLkludmFsaWRTaWduYXR1cmVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgc2lnbmVkIGEgaGFzaGVkIG1lc3NhZ2UgKCdoYXNoJykgd2l0aFxuICAgICAqICdzaWduYXR1cmUnLiBUaGlzIGFkZHJlc3MgY2FuIHRoZW4gYmUgdXNlZCBmb3IgdmVyaWZpY2F0aW9uIHB1cnBvc2VzLlxuICAgICAqXG4gICAgICogVGhlICdlY3JlY292ZXInIEVWTSBvcGNvZGUgYWxsb3dzIGZvciBtYWxsZWFibGUgKG5vbi11bmlxdWUpIHNpZ25hdHVyZXM6XG4gICAgICogdGhpcyBmdW5jdGlvbiByZWplY3RzIHRoZW0gYnkgcmVxdWlyaW5nIHRoZSAncycgdmFsdWUgdG8gYmUgaW4gdGhlIGxvd2VyXG4gICAgICogaGFsZiBvcmRlciwgYW5kIHRoZSAndicgdmFsdWUgdG8gYmUgZWl0aGVyIDI3IG9yIDI4LlxuICAgICAqXG4gICAgICogSU1QT1JUQU5UOiAnaGFzaCcgX211c3RfIGJlIHRoZSByZXN1bHQgb2YgYSBoYXNoIG9wZXJhdGlvbiBmb3IgdGhlXG4gICAgICogdmVyaWZpY2F0aW9uIHRvIGJlIHNlY3VyZTogaXQgaXMgcG9zc2libGUgdG8gY3JhZnQgc2lnbmF0dXJlcyB0aGF0XG4gICAgICogcmVjb3ZlciB0byBhcmJpdHJhcnkgYWRkcmVzc2VzIGZvciBub24taGFzaGVkIGRhdGEuIEEgc2FmZSB3YXkgdG8gZW5zdXJlXG4gICAgICogdGhpcyBpcyBieSByZWNlaXZpbmcgYSBoYXNoIG9mIHRoZSBvcmlnaW5hbCBtZXNzYWdlICh3aGljaCBtYXkgb3RoZXJ3aXNlXG4gICAgICogYmUgdG9vIGxvbmcpLCBhbmQgdGhlbiBjYWxsaW5nIHt0b0V0aFNpZ25lZE1lc3NhZ2VIYXNofSBvbiBpdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWNvdmVyKGJ5dGVzMzIgaGFzaCwgYnl0ZXMgbWVtb3J5IHNpZ25hdHVyZSlcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgcHVyZVxuICAgICAgICByZXR1cm5zIChhZGRyZXNzKVxuICAgIHtcbiAgICAgICAgKGFkZHJlc3MgcmVjb3ZlcmVkLCBSZWNvdmVyRXJyb3IgZXJyb3IpID0gdHJ5UmVjb3ZlcihoYXNoLCBzaWduYXR1cmUpO1xuICAgICAgICBfdGhyb3dFcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiByZWNvdmVyZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRldiBPdmVybG9hZCBvZiB7RUNEU0EtdHJ5UmVjb3Zlcn0gdGhhdCByZWNlaXZlcyB0aGUgJ3InIGFuZCAndnMnIHNob3J0LXNpZ25hdHVyZSBmaWVsZHMgc2VwYXJhdGVseS5cbiAgICAgKlxuICAgICAqIFNlZSBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTIwOThbRUlQLTIwOTggc2hvcnQgc2lnbmF0dXJlc11cbiAgICAgKlxuICAgICAqIF9BdmFpbGFibGUgc2luY2UgdjQuMy5fXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ5UmVjb3ZlcihcbiAgICAgICAgYnl0ZXMzMiBoYXNoLFxuICAgICAgICBieXRlczMyIHIsXG4gICAgICAgIGJ5dGVzMzIgdnNcbiAgICApIGludGVybmFsIHB1cmUgcmV0dXJucyAoYWRkcmVzcywgUmVjb3ZlckVycm9yKSB7XG4gICAgICAgIGJ5dGVzMzIgcyA9IHZzICZcbiAgICAgICAgICAgIGJ5dGVzMzIoXG4gICAgICAgICAgICAgICAgMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXG4gICAgICAgICAgICApO1xuICAgICAgICB1aW50OCB2ID0gdWludDgoKHVpbnQyNTYodnMpID4+IDI1NSkgKyAyNyk7XG4gICAgICAgIHJldHVybiB0cnlSZWNvdmVyKGhhc2gsIHYsIHIsIHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgT3ZlcmxvYWQgb2Yge0VDRFNBLXJlY292ZXJ9IHRoYXQgcmVjZWl2ZXMgdGhlICdyIGFuZCAndnMnIHNob3J0LXNpZ25hdHVyZSBmaWVsZHMgc2VwYXJhdGVseS5cbiAgICAgKlxuICAgICAqIF9BdmFpbGFibGUgc2luY2UgdjQuMi5fXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjb3ZlcihcbiAgICAgICAgYnl0ZXMzMiBoYXNoLFxuICAgICAgICBieXRlczMyIHIsXG4gICAgICAgIGJ5dGVzMzIgdnNcbiAgICApIGludGVybmFsIHB1cmUgcmV0dXJucyAoYWRkcmVzcykge1xuICAgICAgICAoYWRkcmVzcyByZWNvdmVyZWQsIFJlY292ZXJFcnJvciBlcnJvcikgPSB0cnlSZWNvdmVyKGhhc2gsIHIsIHZzKTtcbiAgICAgICAgX3Rocm93RXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gcmVjb3ZlcmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgT3ZlcmxvYWQgb2Yge0VDRFNBLXRyeVJlY292ZXJ9IHRoYXQgcmVjZWl2ZXMgdGhlICd2JyxcbiAgICAgKiAncicgYW5kICdzJyBzaWduYXR1cmUgZmllbGRzIHNlcGFyYXRlbHkuXG4gICAgICpcbiAgICAgKiBfQXZhaWxhYmxlIHNpbmNlIHY0LjMuX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyeVJlY292ZXIoXG4gICAgICAgIGJ5dGVzMzIgaGFzaCxcbiAgICAgICAgdWludDggdixcbiAgICAgICAgYnl0ZXMzMiByLFxuICAgICAgICBieXRlczMyIHNcbiAgICApIGludGVybmFsIHB1cmUgcmV0dXJucyAoYWRkcmVzcywgUmVjb3ZlckVycm9yKSB7XG4gICAgICAgIC8vIEVJUC0yIHN0aWxsIGFsbG93cyBzaWduYXR1cmUgbWFsbGVhYmlsaXR5IGZvciBlY3JlY292ZXIoKS4gUmVtb3ZlIHRoaXMgcG9zc2liaWxpdHkgYW5kIG1ha2UgdGhlIHNpZ25hdHVyZVxuICAgICAgICAvLyB1bmlxdWUuIEFwcGVuZGl4IEYgaW4gdGhlIEV0aGVyZXVtIFllbGxvdyBwYXBlciAoaHR0cHM6Ly9ldGhlcmV1bS5naXRodWIuaW8veWVsbG93cGFwZXIvcGFwZXIucGRmKSwgZGVmaW5lc1xuICAgICAgICAvLyB0aGUgdmFsaWQgcmFuZ2UgZm9yIHMgaW4gKDMwMSk6IDAgPCBzIDwgc2VjcDI1NmsxbiDDtyAyICsgMSwgYW5kIGZvciB2IGluICgzMDIpOiB2IOKIiCB7MjcsIDI4fS4gTW9zdFxuICAgICAgICAvLyBzaWduYXR1cmVzIGZyb20gY3VycmVudCBsaWJyYXJpZXMgZ2VuZXJhdGUgYSB1bmlxdWUgc2lnbmF0dXJlIHdpdGggYW4gcy12YWx1ZSBpbiB0aGUgbG93ZXIgaGFsZiBvcmRlci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgeW91ciBsaWJyYXJ5IGdlbmVyYXRlcyBtYWxsZWFibGUgc2lnbmF0dXJlcywgc3VjaCBhcyBzLXZhbHVlcyBpbiB0aGUgdXBwZXIgcmFuZ2UsIGNhbGN1bGF0ZSBhIG5ldyBzLXZhbHVlXG4gICAgICAgIC8vIHdpdGggMHhGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRUJBQUVEQ0U2QUY0OEEwM0JCRkQyNUU4Q0QwMzY0MTQxIC0gczEgYW5kIGZsaXAgdiBmcm9tIDI3IHRvIDI4IG9yXG4gICAgICAgIC8vIHZpY2UgdmVyc2EuIElmIHlvdXIgbGlicmFyeSBhbHNvIGdlbmVyYXRlcyBzaWduYXR1cmVzIHdpdGggMC8xIGZvciB2IGluc3RlYWQgMjcvMjgsIGFkZCAyNyB0byB2IHRvIGFjY2VwdFxuICAgICAgICAvLyB0aGVzZSBtYWxsZWFibGUgc2lnbmF0dXJlcyBhcyB3ZWxsLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB1aW50MjU2KHMpID5cbiAgICAgICAgICAgIDB4N0ZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY1RDU3NkU3MzU3QTQ1MDFEREZFOTJGNDY2ODFCMjBBMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAoYWRkcmVzcygwKSwgUmVjb3ZlckVycm9yLkludmFsaWRTaWduYXR1cmVTKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiAhPSAyNyAmJiB2ICE9IDI4KSB7XG4gICAgICAgICAgICByZXR1cm4gKGFkZHJlc3MoMCksIFJlY292ZXJFcnJvci5JbnZhbGlkU2lnbmF0dXJlVik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkIChhbmQgbm90IG1hbGxlYWJsZSksIHJldHVybiB0aGUgc2lnbmVyIGFkZHJlc3NcbiAgICAgICAgYWRkcmVzcyBzaWduZXIgPSBlY3JlY292ZXIoaGFzaCwgdiwgciwgcyk7XG4gICAgICAgIGlmIChzaWduZXIgPT0gYWRkcmVzcygwKSkge1xuICAgICAgICAgICAgcmV0dXJuIChhZGRyZXNzKDApLCBSZWNvdmVyRXJyb3IuSW52YWxpZFNpZ25hdHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHNpZ25lciwgUmVjb3ZlckVycm9yLk5vRXJyb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXYgT3ZlcmxvYWQgb2Yge0VDRFNBLXJlY292ZXJ9IHRoYXQgcmVjZWl2ZXMgdGhlICd2JyxcbiAgICAgKiAncicgYW5kICdzJyBzaWduYXR1cmUgZmllbGRzIHNlcGFyYXRlbHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVjb3ZlcihcbiAgICAgICAgYnl0ZXMzMiBoYXNoLFxuICAgICAgICB1aW50OCB2LFxuICAgICAgICBieXRlczMyIHIsXG4gICAgICAgIGJ5dGVzMzIgc1xuICAgICkgaW50ZXJuYWwgcHVyZSByZXR1cm5zIChhZGRyZXNzKSB7XG4gICAgICAgIChhZGRyZXNzIHJlY292ZXJlZCwgUmVjb3ZlckVycm9yIGVycm9yKSA9IHRyeVJlY292ZXIoaGFzaCwgdiwgciwgcyk7XG4gICAgICAgIF90aHJvd0Vycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHJlY292ZXJlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFJldHVybnMgYW4gRXRoZXJldW0gU2lnbmVkIE1lc3NhZ2UsIGNyZWF0ZWQgZnJvbSBhICdoYXNoJy4gVGhpc1xuICAgICAqIHByb2R1Y2VzIGhhc2ggY29ycmVzcG9uZGluZyB0byB0aGUgb25lIHNpZ25lZCB3aXRoIHRoZVxuICAgICAqIGh0dHBzOi8vZXRoLndpa2kvanNvbi1ycGMvQVBJI2V0aF9zaWduWydldGhfc2lnbiddXG4gICAgICogSlNPTi1SUEMgbWV0aG9kIGFzIHBhcnQgb2YgRUlQLTE5MS5cbiAgICAgKlxuICAgICAqIFNlZSB7cmVjb3Zlcn0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9FdGhTaWduZWRNZXNzYWdlSGFzaChieXRlczMyIGhhc2gpXG4gICAgICAgIGludGVybmFsXG4gICAgICAgIHB1cmVcbiAgICAgICAgcmV0dXJucyAoYnl0ZXMzMilcbiAgICB7XG4gICAgICAgIC8vIDMyIGlzIHRoZSBsZW5ndGggaW4gYnl0ZXMgb2YgaGFzaCxcbiAgICAgICAgLy8gZW5mb3JjZWQgYnkgdGhlIHR5cGUgc2lnbmF0dXJlIGFib3ZlXG4gICAgICAgIHJldHVyblxuICAgICAgICAgICAga2VjY2FrMjU2KFxuICAgICAgICAgICAgICAgIGFiaS5lbmNvZGVQYWNrZWQoXCJcXFxceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxcXG4zMlwiLCBoYXNoKVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFJldHVybnMgYW4gRXRoZXJldW0gU2lnbmVkIE1lc3NhZ2UsIGNyZWF0ZWQgZnJvbSAncycuIFRoaXNcbiAgICAgKiBwcm9kdWNlcyBoYXNoIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG9uZSBzaWduZWQgd2l0aCB0aGVcbiAgICAgKiBodHRwczovL2V0aC53aWtpL2pzb24tcnBjL0FQSSNldGhfc2lnblsnZXRoX3NpZ24nXVxuICAgICAqIEpTT04tUlBDIG1ldGhvZCBhcyBwYXJ0IG9mIEVJUC0xOTEuXG4gICAgICpcbiAgICAgKiBTZWUge3JlY292ZXJ9LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRXRoU2lnbmVkTWVzc2FnZUhhc2goYnl0ZXMgbWVtb3J5IHMpXG4gICAgICAgIGludGVybmFsXG4gICAgICAgIHB1cmVcbiAgICAgICAgcmV0dXJucyAoYnl0ZXMzMilcbiAgICB7XG4gICAgICAgIHJldHVyblxuICAgICAgICAgICAga2VjY2FrMjU2KFxuICAgICAgICAgICAgICAgIGFiaS5lbmNvZGVQYWNrZWQoXG4gICAgICAgICAgICAgICAgICAgIFwiXFxcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcXFxuXCIsXG4gICAgICAgICAgICAgICAgICAgIFN0cmluZ3MudG9TdHJpbmcocy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGV2IFJldHVybnMgYW4gRXRoZXJldW0gU2lnbmVkIFR5cGVkIERhdGEsIGNyZWF0ZWQgZnJvbSBhXG4gICAgICogJ2RvbWFpblNlcGFyYXRvcicgYW5kIGEgJ3N0cnVjdEhhc2gnLiBUaGlzIHByb2R1Y2VzIGhhc2ggY29ycmVzcG9uZGluZ1xuICAgICAqIHRvIHRoZSBvbmUgc2lnbmVkIHdpdGggdGhlXG4gICAgICogaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03MTJbJ2V0aF9zaWduVHlwZWREYXRhJ11cbiAgICAgKiBKU09OLVJQQyBtZXRob2QgYXMgcGFydCBvZiBFSVAtNzEyLlxuICAgICAqXG4gICAgICogU2VlIHtyZWNvdmVyfS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1R5cGVkRGF0YUhhc2goYnl0ZXMzMiBkb21haW5TZXBhcmF0b3IsIGJ5dGVzMzIgc3RydWN0SGFzaClcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgcHVyZVxuICAgICAgICByZXR1cm5zIChieXRlczMyKVxuICAgIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICBrZWNjYWsyNTYoXG4gICAgICAgICAgICAgICAgYWJpLmVuY29kZVBhY2tlZChcIlxcXFx4MTlcXFxceDAxXCIsIGRvbWFpblNlcGFyYXRvciwgc3RydWN0SGFzaClcbiAgICAgICAgICAgICk7XG4gICAgfVxufVxuXG5cbnByYWdtYSBzb2xpZGl0eSBeMC44LjA7XG5cbmNvbnRyYWN0ICR7bm9ybWFsaXplU3RyaW5nKGNvbnRyYWN0TmFtZSl9IGlzIE93bmFibGUsIEVSQzcyMVVSSVN0b3JhZ2Uge1xuICAgICAgICB1c2luZyBDb3VudGVycyBmb3IgQ291bnRlcnMuQ291bnRlcjtcbiAgICAgICAgQ291bnRlcnMuQ291bnRlciBwcml2YXRlIG5leHRUb2tlbklkO1xuICAgICAgICB1c2luZyBFQ0RTQSBmb3IgYnl0ZXMzMjtcbiAgICAgICAgc3RydWN0IFNhbGVDb25maWcge1xuICAgICAgICAgICAgYm9vbCBzdGF0dXM7XG4gICAgICAgICAgICB1aW50MjU2IHN0YXJ0VGltZTtcbiAgICAgICAgICAgIHVpbnQyNTYgZW5kVGltZTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICB1aW50MjU2IHB1YmxpYyBwcml2YXRlTWludENoYXJnZTtcbiAgICAgICAgdWludDI1NiBwdWJsaWMgcHVibGljTWludENoYXJnZTtcbiAgICBcbiAgICAgICAgYnl0ZXMzMiBwdWJsaWMgd2hpdGVsaXN0Um9vdDtcbiAgICBcbiAgICAgICAgYWRkcmVzcyBwdWJsaWMgZmVlRGVzdGluYXRpb247XG4gICAgXG4gICAgICAgIFNhbGVDb25maWcgcHVibGljIHByaXZhdGVTYWxlMTtcbiAgICAgICAgU2FsZUNvbmZpZyBwdWJsaWMgcHJpdmF0ZVNhbGUyO1xuICAgICAgICBTYWxlQ29uZmlnIHB1YmxpYyBwdWJsaWNTYWxlO1xuICAgIFxuICAgICAgICB1aW50MjU2IHB1YmxpYyBtYXhNaW50SW5Qcml2YXRlO1xuICAgICAgICB1aW50MjU2IHB1YmxpYyBtYXhNaW50SW5QdWJsaWM7XG4gICAgXG4gICAgICAgIG1hcHBpbmcoYnl0ZXMgPT4gYm9vbCkgcHVibGljIGlzU2lnbmF0dXJlUmVkZWVtZWQ7XG4gICAgXG4gICAgICAgIGV2ZW50IE1pbnQoYWRkcmVzcyBtc2dTZW5kZXIsIHN0cmluZyB0b2tlblVyaSwgdWludDI1NiB0b2tlbklkKTtcbiAgICBcbiAgICAgICAgY29uc3RydWN0b3IoXG4gICAgICAgICAgICBhZGRyZXNzIF9mZWVEZXN0aW5hdGlvbixcbiAgICAgICAgICAgIGJ5dGVzMzIgX3doaXRlbGlzdFJvb3QsXG4gICAgICAgICAgICB1aW50MjU2IF9wcml2YXRlTWludENoYXJnZSxcbiAgICAgICAgICAgIHVpbnQyNTYgX3B1YmxpY01pbnRDaGFyZ2UsXG4gICAgICAgICAgICBzdHJpbmcgbWVtb3J5IF9uYW1lLFxuICAgICAgICAgICAgc3RyaW5nIG1lbW9yeSBfc3ltYm9sXG4gICAgICAgICkgRVJDNzIxKF9uYW1lLCBfc3ltYm9sKSB7XG4gICAgICAgICAgICBmZWVEZXN0aW5hdGlvbiA9IF9mZWVEZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHdoaXRlbGlzdFJvb3QgPSBfd2hpdGVsaXN0Um9vdDtcbiAgICAgICAgICAgIHByaXZhdGVNaW50Q2hhcmdlID0gX3ByaXZhdGVNaW50Q2hhcmdlO1xuICAgICAgICAgICAgcHVibGljTWludENoYXJnZSA9IF9wdWJsaWNNaW50Q2hhcmdlO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU1heE1pbnRJblByaXZhdGUodWludDI1NiBfbWF4TWludEluUHJpdmF0ZSlcbiAgICAgICAgICAgIHB1YmxpY1xuICAgICAgICAgICAgb25seU93bmVyXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1heE1pbnRJblByaXZhdGUgPSBfbWF4TWludEluUHJpdmF0ZTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVNYXhNaW50SW5QdWJsaWModWludDI1NiBfbWF4TWludEluUHVibGljKSBwdWJsaWMgb25seU93bmVyIHtcbiAgICAgICAgICAgIG1heE1pbnRJblB1YmxpYyA9IF9tYXhNaW50SW5QdWJsaWM7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlUHJpdmF0ZU1pbnRDaGFyZ2UodWludDI1NiBjaGFyZ2UpIHB1YmxpYyBvbmx5T3duZXIge1xuICAgICAgICAgICAgcHJpdmF0ZU1pbnRDaGFyZ2UgPSBjaGFyZ2U7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlUHVibGljTWludENoYXJnZSh1aW50MjU2IGNoYXJnZSkgcHVibGljIG9ubHlPd25lciB7XG4gICAgICAgICAgICBwdWJsaWNNaW50Q2hhcmdlID0gY2hhcmdlO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVByaXZhdGVTYWxlMShcbiAgICAgICAgICAgIHVpbnQyNTYgX3N0YXJ0VGltZSxcbiAgICAgICAgICAgIHVpbnQyNTYgX2VuZFRpbWUsXG4gICAgICAgICAgICBib29sIF9zdGF0dXNcbiAgICAgICAgKSBwdWJsaWMgb25seU93bmVyIHtcbiAgICAgICAgICAgIHByaXZhdGVTYWxlMS5zdGFydFRpbWUgPSBfc3RhcnRUaW1lO1xuICAgICAgICAgICAgcHJpdmF0ZVNhbGUxLmVuZFRpbWUgPSBfZW5kVGltZTtcbiAgICAgICAgICAgIHByaXZhdGVTYWxlMS5zdGF0dXMgPSBfc3RhdHVzO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVByaXZhdGVTYWxlMihcbiAgICAgICAgICAgIHVpbnQyNTYgX3N0YXJ0VGltZSxcbiAgICAgICAgICAgIHVpbnQyNTYgX2VuZFRpbWUsXG4gICAgICAgICAgICBib29sIF9zdGF0dXNcbiAgICAgICAgKSBwdWJsaWMgb25seU93bmVyIHtcbiAgICAgICAgICAgIHByaXZhdGVTYWxlMi5zdGFydFRpbWUgPSBfc3RhcnRUaW1lO1xuICAgICAgICAgICAgcHJpdmF0ZVNhbGUyLmVuZFRpbWUgPSBfZW5kVGltZTtcbiAgICAgICAgICAgIHByaXZhdGVTYWxlMi5zdGF0dXMgPSBfc3RhdHVzO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVB1YmxpY1NhbGUoXG4gICAgICAgICAgICB1aW50MjU2IF9zdGFydFRpbWUsXG4gICAgICAgICAgICB1aW50MjU2IF9lbmRUaW1lLFxuICAgICAgICAgICAgYm9vbCBfc3RhdHVzXG4gICAgICAgICkgcHVibGljIG9ubHlPd25lciB7XG4gICAgICAgICAgICBwdWJsaWNTYWxlLnN0YXJ0VGltZSA9IF9zdGFydFRpbWU7XG4gICAgICAgICAgICBwdWJsaWNTYWxlLmVuZFRpbWUgPSBfZW5kVGltZTtcbiAgICAgICAgICAgIHB1YmxpY1NhbGUuc3RhdHVzID0gX3N0YXR1cztcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVXaGl0ZWxpc3QoYnl0ZXMzMiBfcm9vdCkgcHVibGljIG9ubHlPd25lciB7XG4gICAgICAgICAgICB3aGl0ZWxpc3RSb290ID0gX3Jvb3Q7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlRmVlVG9BZGRyZXNzKGFkZHJlc3MgX2ZlZURlc3RpbmF0aW9uKSBwdWJsaWMgb25seU93bmVyIHtcbiAgICAgICAgICAgIGZlZURlc3RpbmF0aW9uID0gX2ZlZURlc3RpbmF0aW9uO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRva2VuVXJpKHVpbnQyNTYgdG9rZW5JZCwgc3RyaW5nIG1lbW9yeSBfdG9rZW5VUkkpXG4gICAgICAgICAgICBwdWJsaWNcbiAgICAgICAgICAgIG9ubHlPd25lclxuICAgICAgICB7XG4gICAgICAgICAgICBfc2V0VG9rZW5VUkkodG9rZW5JZCwgX3Rva2VuVVJJKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBtb2RpZmllciBwcml2YXRlRmVlUHJvdmlkZWQoKSB7XG4gICAgICAgICAgICByZXF1aXJlKG1zZy52YWx1ZSA+PSBwcml2YXRlTWludENoYXJnZSwgXCJGZWUgbm90IHByb3ZpZGVkXCIpO1xuICAgICAgICAgICAgcGF5YWJsZShmZWVEZXN0aW5hdGlvbikudHJhbnNmZXIobXNnLnZhbHVlKTtcbiAgICAgICAgICAgIF87XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgbW9kaWZpZXIgcHVibGljRmVlUHJvdmlkZWQoKSB7XG4gICAgICAgICAgICByZXF1aXJlKG1zZy52YWx1ZSA+PSBwdWJsaWNNaW50Q2hhcmdlLCBcIkZlZSBub3QgcHJvdmlkZWRcIik7XG4gICAgICAgICAgICBwYXlhYmxlKGZlZURlc3RpbmF0aW9uKS50cmFuc2Zlcihtc2cudmFsdWUpO1xuICAgICAgICAgICAgXztcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBtb2RpZmllciBvbmx5V2hpdGVsaXN0ZWQoYnl0ZXMzMltdIG1lbW9yeSBwcm9vZikge1xuICAgICAgICAgICAgcmVxdWlyZShcbiAgICAgICAgICAgICAgICBNZXJrbGVQcm9vZi52ZXJpZnkoXG4gICAgICAgICAgICAgICAgICAgIHByb29mLFxuICAgICAgICAgICAgICAgICAgICB3aGl0ZWxpc3RSb290LFxuICAgICAgICAgICAgICAgICAgICBrZWNjYWsyNTYoYWJpLmVuY29kZVBhY2tlZChtc2cuc2VuZGVyKSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFwiTm90IHdoaXRlbGlzdGVkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBfO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIG1vZGlmaWVyIG9ubHlQcml2YXRlU2FsZSgpIHtcbiAgICAgICAgICAgIHVpbnQyNTYgdGltZSA9IGJsb2NrLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIHJlcXVpcmUoXG4gICAgICAgICAgICAgICAgKHByaXZhdGVTYWxlMS5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICAgdGltZSA+IHByaXZhdGVTYWxlMS5zdGFydFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgKHByaXZhdGVTYWxlMS5lbmRUaW1lID4gdGltZSB8fCBwcml2YXRlU2FsZTEuZW5kVGltZSA9PSAwKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHByaXZhdGVTYWxlMi5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUgPiBwcml2YXRlU2FsZTIuc3RhcnRUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocHJpdmF0ZVNhbGUyLmVuZFRpbWUgPiB0aW1lIHx8IHByaXZhdGVTYWxlMi5lbmRUaW1lID09IDApKSxcbiAgICAgICAgICAgICAgICBcIk5vdCBhIHByaXZhdGUgc2FsZVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgXztcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBtb2RpZmllciBvbmx5UHVibGljU2FsZSgpIHtcbiAgICAgICAgICAgIHVpbnQyNTYgdGltZSA9IGJsb2NrLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIHJlcXVpcmUoXG4gICAgICAgICAgICAgICAgcHVibGljU2FsZS5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICAgdGltZSA+IHB1YmxpY1NhbGUuc3RhcnRUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIChwdWJsaWNTYWxlLmVuZFRpbWUgPiB0aW1lIHx8IHB1YmxpY1NhbGUuZW5kVGltZSA9PSAwKSxcbiAgICAgICAgICAgICAgICBcIk5vdCBhIHB1YmxpYyBzYWxlXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBfO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIG1vZGlmaWVyIG9ubHlWYWxpZFRva2VuVXJpKFxuICAgICAgICAgICAgc3RyaW5nIG1lbW9yeSBfdG9rZW5VUkksXG4gICAgICAgICAgICBieXRlcyBtZW1vcnkgc2lnbmF0dXJlXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmVxdWlyZSghaXNTaWduYXR1cmVSZWRlZW1lZFtzaWduYXR1cmVdLCBcIlNpZ25hdHVyZSBhbHJlYWR5IHJlZGVlbWVkXCIpO1xuICAgICAgICAgICAgcmVxdWlyZShcbiAgICAgICAgICAgICAgICBrZWNjYWsyNTYoYWJpLmVuY29kZVBhY2tlZChfdG9rZW5VUkkpKVxuICAgICAgICAgICAgICAgICAgICAudG9FdGhTaWduZWRNZXNzYWdlSGFzaCgpXG4gICAgICAgICAgICAgICAgICAgIC5yZWNvdmVyKHNpZ25hdHVyZSkgPT0gb3duZXIoKSxcbiAgICAgICAgICAgICAgICBcIkludmFsaWQgdG9rZW4gVVJJXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBfO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIG1vZGlmaWVyIG1heFByaXZhdGVMaW1pdE5vdFJlYWNoZWQoKSB7XG4gICAgICAgICAgICBpZiAobWF4TWludEluUHJpdmF0ZSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZShcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZU9mKG1zZy5zZW5kZXIpIDwgbWF4TWludEluUHJpdmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJNYXggbGltaXQgcmVhY2hlZFwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF87XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgbW9kaWZpZXIgbWF4UHVibGljTGltaXROb3RSZWFjaGVkKCkge1xuICAgICAgICAgICAgaWYgKG1heE1pbnRJblB1YmxpYyAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZShcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZU9mKG1zZy5zZW5kZXIpIDwgbWF4TWludEluUHVibGljLFxuICAgICAgICAgICAgICAgICAgICBcIk1heCBsaW1pdCByZWFjaGVkXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXztcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBtaW50UHJpdmF0ZShcbiAgICAgICAgICAgIHN0cmluZyBtZW1vcnkgX3Rva2VuVVJJLFxuICAgICAgICAgICAgYnl0ZXMzMltdIG1lbW9yeSBwcm9vZixcbiAgICAgICAgICAgIGJ5dGVzIG1lbW9yeSBzaWduYXR1cmVcbiAgICAgICAgKVxuICAgICAgICAgICAgcHVibGljXG4gICAgICAgICAgICBwYXlhYmxlXG4gICAgICAgICAgICBvbmx5UHJpdmF0ZVNhbGVcbiAgICAgICAgICAgIG1heFByaXZhdGVMaW1pdE5vdFJlYWNoZWRcbiAgICAgICAgICAgIG9ubHlXaGl0ZWxpc3RlZChwcm9vZilcbiAgICAgICAgICAgIG9ubHlWYWxpZFRva2VuVXJpKF90b2tlblVSSSwgc2lnbmF0dXJlKVxuICAgICAgICAgICAgcHJpdmF0ZUZlZVByb3ZpZGVkXG4gICAgICAgIHtcbiAgICAgICAgICAgIF9taW50KG1zZy5zZW5kZXIsIG5leHRUb2tlbklkLmN1cnJlbnQoKSk7XG4gICAgICAgICAgICBfc2V0VG9rZW5VUkkobmV4dFRva2VuSWQuY3VycmVudCgpLCBfdG9rZW5VUkkpO1xuICAgICAgICAgICAgaXNTaWduYXR1cmVSZWRlZW1lZFtzaWduYXR1cmVdID0gdHJ1ZTtcbiAgICAgICAgICAgIGVtaXQgTWludChtc2cuc2VuZGVyLCBfdG9rZW5VUkksIG5leHRUb2tlbklkLmN1cnJlbnQoKSk7XG4gICAgICAgICAgICBuZXh0VG9rZW5JZC5pbmNyZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBtaW50KHN0cmluZyBtZW1vcnkgX3Rva2VuVVJJLCBieXRlcyBtZW1vcnkgc2lnbmF0dXJlKVxuICAgICAgICAgICAgcHVibGljXG4gICAgICAgICAgICBwYXlhYmxlXG4gICAgICAgICAgICBvbmx5UHVibGljU2FsZVxuICAgICAgICAgICAgbWF4UHVibGljTGltaXROb3RSZWFjaGVkXG4gICAgICAgICAgICBvbmx5VmFsaWRUb2tlblVyaShfdG9rZW5VUkksIHNpZ25hdHVyZSlcbiAgICAgICAgICAgIHB1YmxpY0ZlZVByb3ZpZGVkXG4gICAgICAgIHtcbiAgICAgICAgICAgIF9taW50KG1zZy5zZW5kZXIsIG5leHRUb2tlbklkLmN1cnJlbnQoKSk7XG4gICAgICAgICAgICBfc2V0VG9rZW5VUkkobmV4dFRva2VuSWQuY3VycmVudCgpLCBfdG9rZW5VUkkpO1xuICAgICAgICAgICAgaXNTaWduYXR1cmVSZWRlZW1lZFtzaWduYXR1cmVdID0gdHJ1ZTtcbiAgICAgICAgICAgIGVtaXQgTWludChtc2cuc2VuZGVyLCBfdG9rZW5VUkksIG5leHRUb2tlbklkLmN1cnJlbnQoKSk7XG4gICAgICAgICAgICBuZXh0VG9rZW5JZC5pbmNyZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcblxuICAgIGA7XG59O1xuIl0sIm5hbWVzIjpbIm5vcm1hbGl6ZVN0cmluZyIsImdldDcyMUNvbnRyYWN0Q29kZSIsImNvbnRyYWN0TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./services/contract.service.ts\n");

/***/ }),

/***/ "(api)/./services/discord.service.ts":
/*!*************************************!*\
  !*** ./services/discord.service.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getDiscordUsersCreds\": () => (/* binding */ getDiscordUsersCreds),\n/* harmony export */   \"getUserByAccessToken\": () => (/* binding */ getUserByAccessToken),\n/* harmony export */   \"removeDiscordAccessToken\": () => (/* binding */ removeDiscordAccessToken)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"axios\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var cookies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cookies */ \"cookies\");\n/* harmony import */ var cookies__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(cookies__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _constants_configuration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/configuration */ \"(api)/./constants/configuration.ts\");\n\n\n\nconst removeDiscordAccessToken = (req, res)=>{\n    const cookie = new (cookies__WEBPACK_IMPORTED_MODULE_1___default())(req, res);\n    cookie.set(_constants_configuration__WEBPACK_IMPORTED_MODULE_2__.ACCESS_TOKEN_COOKIE_KEY, \"\", {\n        expires: new Date(Date.now() - 86400)\n    });\n};\nconst getUserByAccessToken = async (accessToken)=>{\n    try {\n        const { data: user  } = await axios__WEBPACK_IMPORTED_MODULE_0___default().get(`https://discord.com/api/v8/users/@me`, {\n            headers: {\n                Authorization: `Bearer ${accessToken}`\n            }\n        });\n        return user;\n    } catch (error) {\n        console.log(\"Error fetching user from discord : \", error);\n        return null;\n    }\n};\nconst getDiscordUsersCreds = async (code, host)=>{\n    const payload = new URLSearchParams({\n        client_id: _constants_configuration__WEBPACK_IMPORTED_MODULE_2__.DISCORD_OAUTH_CLIENT_ID,\n        client_secret: _constants_configuration__WEBPACK_IMPORTED_MODULE_2__.DISCORD_OAUTH_CLIENT_SECRET,\n        grant_type: \"authorization_code\",\n        code,\n        redirect_uri: `${_constants_configuration__WEBPACK_IMPORTED_MODULE_2__.ENV_PROTOCOL}://${host}/api/v1/auth/discord/redirect`\n    }).toString();\n    const { data: creds  } = await axios__WEBPACK_IMPORTED_MODULE_0___default().post(\"https://discord.com/api/v8/oauth2/token\", payload, {\n        headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n    });\n    const { data: user  } = await axios__WEBPACK_IMPORTED_MODULE_0___default().get(`https://discord.com/api/v8/users/@me`, {\n        headers: {\n            Authorization: `Bearer ${creds.access_token}`\n        }\n    });\n    return {\n        user,\n        creds\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zZXJ2aWNlcy9kaXNjb3JkLnNlcnZpY2UudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMEI7QUFDSTtBQU9NO0FBRzdCLE1BQU1NLHdCQUF3QixHQUFHLENBQ3RDQyxHQUFtQixFQUNuQkMsR0FBb0IsR0FDakI7SUFDSCxNQUFNQyxNQUFNLEdBQUcsSUFBSVIsZ0RBQU8sQ0FBQ00sR0FBRyxFQUFFQyxHQUFHLENBQUM7SUFDcENDLE1BQU0sQ0FBQ0MsR0FBRyxDQUFDUiw2RUFBdUIsRUFBRSxFQUFFLEVBQUU7UUFDdENTLE9BQU8sRUFBRSxJQUFJQyxJQUFJLENBQUNBLElBQUksQ0FBQ0MsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFDO0tBQ3RDLENBQUMsQ0FBQztDQUNKLENBQUM7QUFFSyxNQUFNQyxvQkFBb0IsR0FBRyxPQUFPQyxXQUFtQixHQUFLO0lBQ2pFLElBQUk7UUFDRixNQUFNLEVBQUVDLElBQUksRUFBRUMsSUFBSSxHQUFFLEdBQWtDLE1BQU1qQixnREFBUyxDQUNuRSxDQUFDLG9DQUFvQyxDQUFDLEVBQ3RDO1lBQ0VtQixPQUFPLEVBQUU7Z0JBQUVDLGFBQWEsRUFBRSxDQUFDLE9BQU8sRUFBRUwsV0FBVyxDQUFDLENBQUM7YUFBRTtTQUNwRCxDQUNGO1FBQ0QsT0FBT0UsSUFBSSxDQUFDO0tBQ2IsQ0FBQyxPQUFPSSxLQUFLLEVBQUU7UUFDZEMsT0FBTyxDQUFDQyxHQUFHLENBQUMscUNBQXFDLEVBQUVGLEtBQUssQ0FBQyxDQUFDO1FBRTFELE9BQU8sSUFBSSxDQUFDO0tBQ2I7Q0FDRixDQUFDO0FBRUssTUFBTUcsb0JBQW9CLEdBQUcsT0FBT0MsSUFBWSxFQUFFQyxJQUFZLEdBQUs7SUFDeEUsTUFBTUMsT0FBTyxHQUFHLElBQUlDLGVBQWUsQ0FBQztRQUNsQ0MsU0FBUyxFQUFFMUIsNkVBQXVCO1FBQ2xDMkIsYUFBYSxFQUFFMUIsaUZBQTJCO1FBQzFDMkIsVUFBVSxFQUFFLG9CQUFvQjtRQUNoQ04sSUFBSTtRQUNKTyxZQUFZLEVBQUUsQ0FBQyxFQUFFM0Isa0VBQVksQ0FBQyxHQUFHLEVBQUVxQixJQUFJLENBQUMsNkJBQTZCLENBQUM7S0FDdkUsQ0FBQyxDQUFDTyxRQUFRLEVBQUU7SUFDYixNQUFNLEVBQUVqQixJQUFJLEVBQUVrQixLQUFLLEdBQUUsR0FDbkIsTUFBTWxDLGlEQUFVLENBQUMseUNBQXlDLEVBQUUyQixPQUFPLEVBQUU7UUFDbkVSLE9BQU8sRUFBRTtZQUNQLGNBQWMsRUFBRSxtQ0FBbUM7U0FDcEQ7S0FDRixDQUFDO0lBQ0osTUFBTSxFQUFFSCxJQUFJLEVBQUVDLElBQUksR0FBRSxHQUFrQyxNQUFNakIsZ0RBQVMsQ0FDbkUsQ0FBQyxvQ0FBb0MsQ0FBQyxFQUN0QztRQUNFbUIsT0FBTyxFQUFFO1lBQUVDLGFBQWEsRUFBRSxDQUFDLE9BQU8sRUFBRWMsS0FBSyxDQUFDRSxZQUFZLENBQUMsQ0FBQztTQUFFO0tBQzNELENBQ0Y7SUFDRCxPQUFPO1FBQUVuQixJQUFJO1FBQUVpQixLQUFLO0tBQUUsQ0FBQztDQUN4QixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vc2VydmljZXMvZGlzY29yZC5zZXJ2aWNlLnRzP2I3MTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IENvb2tpZXMgZnJvbSBcImNvb2tpZXNcIjtcbmltcG9ydCB7IE5leHRBcGlSZXNwb25zZSwgTmV4dEFwaVJlcXVlc3QgfSBmcm9tIFwibmV4dFwiO1xuaW1wb3J0IHtcbiAgQUNDRVNTX1RPS0VOX0NPT0tJRV9LRVksXG4gIERJU0NPUkRfT0FVVEhfQ0xJRU5UX0lELFxuICBESVNDT1JEX09BVVRIX0NMSUVOVF9TRUNSRVQsXG4gIEVOVl9QUk9UT0NPTCxcbn0gZnJvbSBcIi4uL2NvbnN0YW50cy9jb25maWd1cmF0aW9uXCI7XG5pbXBvcnQgeyBEaXNjb3JkQWNjZXNzVG9rZW5SZXNwb25zZSwgRGlzY29yZFVzZXJSZXNwb25zZSB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG5leHBvcnQgY29uc3QgcmVtb3ZlRGlzY29yZEFjY2Vzc1Rva2VuID0gKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZVxuKSA9PiB7XG4gIGNvbnN0IGNvb2tpZSA9IG5ldyBDb29raWVzKHJlcSwgcmVzKTtcbiAgY29va2llLnNldChBQ0NFU1NfVE9LRU5fQ09PS0lFX0tFWSwgXCJcIiwge1xuICAgIGV4cGlyZXM6IG5ldyBEYXRlKERhdGUubm93KCkgLSA4NjQwMCksXG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFVzZXJCeUFjY2Vzc1Rva2VuID0gYXN5bmMgKGFjY2Vzc1Rva2VuOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGE6IHVzZXIgfTogeyBkYXRhOiBEaXNjb3JkVXNlclJlc3BvbnNlIH0gPSBhd2FpdCBheGlvcy5nZXQoXG4gICAgICBgaHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvdjgvdXNlcnMvQG1lYCxcbiAgICAgIHtcbiAgICAgICAgaGVhZGVyczogeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCB9LFxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5sb2coXCJFcnJvciBmZXRjaGluZyB1c2VyIGZyb20gZGlzY29yZCA6IFwiLCBlcnJvcik7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldERpc2NvcmRVc2Vyc0NyZWRzID0gYXN5bmMgKGNvZGU6IHN0cmluZywgaG9zdDogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHBheWxvYWQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICBjbGllbnRfaWQ6IERJU0NPUkRfT0FVVEhfQ0xJRU5UX0lELFxuICAgIGNsaWVudF9zZWNyZXQ6IERJU0NPUkRfT0FVVEhfQ0xJRU5UX1NFQ1JFVCxcbiAgICBncmFudF90eXBlOiBcImF1dGhvcml6YXRpb25fY29kZVwiLFxuICAgIGNvZGUsXG4gICAgcmVkaXJlY3RfdXJpOiBgJHtFTlZfUFJPVE9DT0x9Oi8vJHtob3N0fS9hcGkvdjEvYXV0aC9kaXNjb3JkL3JlZGlyZWN0YCxcbiAgfSkudG9TdHJpbmcoKTtcbiAgY29uc3QgeyBkYXRhOiBjcmVkcyB9OiB7IGRhdGE6IERpc2NvcmRBY2Nlc3NUb2tlblJlc3BvbnNlIH0gPVxuICAgIGF3YWl0IGF4aW9zLnBvc3QoXCJodHRwczovL2Rpc2NvcmQuY29tL2FwaS92OC9vYXV0aDIvdG9rZW5cIiwgcGF5bG9hZCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgICAgfSxcbiAgICB9KTtcbiAgY29uc3QgeyBkYXRhOiB1c2VyIH06IHsgZGF0YTogRGlzY29yZFVzZXJSZXNwb25zZSB9ID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgIGBodHRwczovL2Rpc2NvcmQuY29tL2FwaS92OC91c2Vycy9AbWVgLFxuICAgIHtcbiAgICAgIGhlYWRlcnM6IHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2NyZWRzLmFjY2Vzc190b2tlbn1gIH0sXG4gICAgfVxuICApO1xuICByZXR1cm4geyB1c2VyLCBjcmVkcyB9O1xufTtcbiJdLCJuYW1lcyI6WyJheGlvcyIsIkNvb2tpZXMiLCJBQ0NFU1NfVE9LRU5fQ09PS0lFX0tFWSIsIkRJU0NPUkRfT0FVVEhfQ0xJRU5UX0lEIiwiRElTQ09SRF9PQVVUSF9DTElFTlRfU0VDUkVUIiwiRU5WX1BST1RPQ09MIiwicmVtb3ZlRGlzY29yZEFjY2Vzc1Rva2VuIiwicmVxIiwicmVzIiwiY29va2llIiwic2V0IiwiZXhwaXJlcyIsIkRhdGUiLCJub3ciLCJnZXRVc2VyQnlBY2Nlc3NUb2tlbiIsImFjY2Vzc1Rva2VuIiwiZGF0YSIsInVzZXIiLCJnZXQiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImVycm9yIiwiY29uc29sZSIsImxvZyIsImdldERpc2NvcmRVc2Vyc0NyZWRzIiwiY29kZSIsImhvc3QiLCJwYXlsb2FkIiwiVVJMU2VhcmNoUGFyYW1zIiwiY2xpZW50X2lkIiwiY2xpZW50X3NlY3JldCIsImdyYW50X3R5cGUiLCJyZWRpcmVjdF91cmkiLCJ0b1N0cmluZyIsImNyZWRzIiwicG9zdCIsImFjY2Vzc190b2tlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./services/discord.service.ts\n");

/***/ }),

/***/ "(api)/./services/solidity.service.ts":
/*!**************************************!*\
  !*** ./services/solidity.service.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getAbiEvmCodeFromSolidity\": () => (/* binding */ getAbiEvmCodeFromSolidity)\n/* harmony export */ });\n/* harmony import */ var _utils_Solidity_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Solidity.utils */ \"(api)/./utils/Solidity.utils.ts\");\n\nconst getAbiEvmCodeFromSolidity = (name, source)=>{\n    try {\n        const compile = (0,_utils_Solidity_utils__WEBPACK_IMPORTED_MODULE_0__.getContractFile)(name, source);\n        return {\n            abi: compile.abi,\n            bytecode: compile.evm.bytecode.object\n        };\n    } catch (error) {\n        console.log(error);\n        throw error;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zZXJ2aWNlcy9zb2xpZGl0eS5zZXJ2aWNlLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQzBEO0FBRW5ELE1BQU1DLHlCQUF5QixHQUFHLENBQUNDLElBQVksRUFBRUMsTUFBYyxHQUFLO0lBQ3pFLElBQUk7UUFDRixNQUFNQyxPQUFPLEdBQUdKLHNFQUFlLENBQUNFLElBQUksRUFBRUMsTUFBTSxDQUFDO1FBQzdDLE9BQU87WUFBRUUsR0FBRyxFQUFFRCxPQUFPLENBQUNDLEdBQUc7WUFBRUMsUUFBUSxFQUFFRixPQUFPLENBQUNHLEdBQUcsQ0FBQ0QsUUFBUSxDQUFDRSxNQUFNO1NBQUUsQ0FBQztLQUNwRSxDQUFDLE9BQU9DLEtBQUssRUFBRTtRQUNkQyxPQUFPLENBQUNDLEdBQUcsQ0FBQ0YsS0FBSyxDQUFDLENBQUM7UUFDbkIsTUFBTUEsS0FBSyxDQUFDO0tBQ2I7Q0FDRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vc2VydmljZXMvc29saWRpdHkuc2VydmljZS50cz8xYjFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnRyYWN0RmlsZSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgZ2V0Q29udHJhY3RGaWxlIH0gZnJvbSBcIi4uL3V0aWxzL1NvbGlkaXR5LnV0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRBYmlFdm1Db2RlRnJvbVNvbGlkaXR5ID0gKG5hbWU6IHN0cmluZywgc291cmNlOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb21waWxlID0gZ2V0Q29udHJhY3RGaWxlKG5hbWUsIHNvdXJjZSkgYXMgQ29udHJhY3RGaWxlO1xuICAgIHJldHVybiB7IGFiaTogY29tcGlsZS5hYmksIGJ5dGVjb2RlOiBjb21waWxlLmV2bS5ieXRlY29kZS5vYmplY3QgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG4iXSwibmFtZXMiOlsiZ2V0Q29udHJhY3RGaWxlIiwiZ2V0QWJpRXZtQ29kZUZyb21Tb2xpZGl0eSIsIm5hbWUiLCJzb3VyY2UiLCJjb21waWxlIiwiYWJpIiwiYnl0ZWNvZGUiLCJldm0iLCJvYmplY3QiLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./services/solidity.service.ts\n");

/***/ }),

/***/ "(api)/./services/user.service.ts":
/*!**********************************!*\
  !*** ./services/user.service.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getLoggedInUser\": () => (/* binding */ getLoggedInUser),\n/* harmony export */   \"getUserByDiscordIdentifiers\": () => (/* binding */ getUserByDiscordIdentifiers),\n/* harmony export */   \"getUserByWalletAddress\": () => (/* binding */ getUserByWalletAddress),\n/* harmony export */   \"updateUserOnDiscordAuth\": () => (/* binding */ updateUserOnDiscordAuth),\n/* harmony export */   \"updateUserWalletAddress\": () => (/* binding */ updateUserWalletAddress),\n/* harmony export */   \"updateUserWalletAddressOld\": () => (/* binding */ updateUserWalletAddressOld)\n/* harmony export */ });\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/db */ \"(api)/./lib/db.ts\");\n/* harmony import */ var _discord_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./discord.service */ \"(api)/./services/discord.service.ts\");\n/* harmony import */ var _utils_Response_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Response.utils */ \"(api)/./utils/Response.utils.ts\");\n/* harmony import */ var _utils_Request_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Request.utils */ \"(api)/./utils/Request.utils.ts\");\n\n\n\n\nconst getLoggedInUser = async (req)=>{\n    try {\n        const accessToken = (0,_utils_Request_utils__WEBPACK_IMPORTED_MODULE_3__.getAccessTokenFromCookie)(req);\n        if (!accessToken || typeof accessToken !== \"string\") return {\n            data: null,\n            error: \"Access Token Not Found\"\n        };\n        const user = await (0,_discord_service__WEBPACK_IMPORTED_MODULE_1__.getUserByAccessToken)(accessToken);\n        if (user) return (0,_utils_Response_utils__WEBPACK_IMPORTED_MODULE_2__.successResponse)(user);\n        return (0,_utils_Response_utils__WEBPACK_IMPORTED_MODULE_2__.errorResponse)(\"Error fetching user\");\n    } catch (error) {\n        return (0,_utils_Response_utils__WEBPACK_IMPORTED_MODULE_2__.errorResponse)(\"Error fetching user : \" + error);\n    }\n};\nconst getUserByDiscordIdentifiers = async (username, discriminator)=>await _lib_db__WEBPACK_IMPORTED_MODULE_0__.prisma.user.findFirst({\n        where: {\n            discordDiscriminator: +discriminator,\n            discordUsername: username\n        }\n    });\nconst getUserByWalletAddress = async (address)=>await _lib_db__WEBPACK_IMPORTED_MODULE_0__.prisma.user.findFirst({\n        where: {\n            walletAddress: address\n        }\n    });\nconst updateUserWalletAddressOld = async (username, discriminator, walletAddress)=>{\n    return await _lib_db__WEBPACK_IMPORTED_MODULE_0__.prisma.user.update({\n        where: {\n            discordUsername_discordDiscriminator: {\n                discordUsername: username,\n                discordDiscriminator: discriminator\n            }\n        },\n        data: {\n            walletAddress\n        }\n    });\n};\nconst updateUserWalletAddress = async (username, discriminator, walletAddress)=>{\n    await _lib_db__WEBPACK_IMPORTED_MODULE_0__.prisma.user[\"delete\"]({\n        where: {\n            discordUsername_discordDiscriminator: {\n                discordDiscriminator: discriminator,\n                discordUsername: username\n            }\n        }\n    });\n    return await _lib_db__WEBPACK_IMPORTED_MODULE_0__.prisma.user.upsert({\n        where: {\n            walletAddress\n        },\n        create: {\n            discordUsername: username,\n            discordDiscriminator: discriminator,\n            walletAddress\n        },\n        update: {\n            discordDiscriminator: discriminator,\n            discordUsername: username\n        }\n    });\n};\nconst updateUserOnDiscordAuth = async (user, creds)=>{\n    return await _lib_db__WEBPACK_IMPORTED_MODULE_0__.prisma.user.upsert({\n        where: {\n            discordUsername_discordDiscriminator: {\n                discordUsername: user.username,\n                discordDiscriminator: +user.discriminator\n            }\n        },\n        create: {\n            discordUsername: user.username,\n            discordDiscriminator: +user.discriminator,\n            isCreator: false,\n            accessToken: creds.access_token,\n            refreshToken: creds.refresh_token\n        },\n        update: {\n            isCreator: false,\n            accessToken: creds.access_token,\n            refreshToken: creds.refresh_token\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9zZXJ2aWNlcy91c2VyLnNlcnZpY2UudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVtQztBQUVzQjtBQUNnQjtBQU1QO0FBRTNELE1BQU1LLGVBQWUsR0FBRyxPQUFPQyxHQUEwQixHQUFLO0lBQ25FLElBQUk7UUFDRixNQUFNQyxXQUFXLEdBQUdILDhFQUF3QixDQUFDRSxHQUFHLENBQUM7UUFDakQsSUFBSSxDQUFDQyxXQUFXLElBQUksT0FBT0EsV0FBVyxLQUFLLFFBQVEsRUFDakQsT0FBTztZQUFFQyxJQUFJLEVBQUUsSUFBSTtZQUFFQyxLQUFLLEVBQUUsd0JBQXdCO1NBQUUsQ0FBQztRQUN6RCxNQUFNQyxJQUFJLEdBQUcsTUFBTVQsc0VBQW9CLENBQUNNLFdBQVcsQ0FBQztRQUNwRCxJQUFJRyxJQUFJLEVBQUUsT0FBT1Asc0VBQWUsQ0FBQ08sSUFBSSxDQUFDLENBQUM7UUFDdkMsT0FBT1Isb0VBQWEsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0tBQzdDLENBQUMsT0FBT08sS0FBSyxFQUFFO1FBQ2QsT0FBT1Asb0VBQWEsQ0FBQyx3QkFBd0IsR0FBR08sS0FBSyxDQUFDLENBQUM7S0FDeEQ7Q0FDRixDQUFDO0FBRUssTUFBTUUsMkJBQTJCLEdBQUcsT0FDekNDLFFBQWdCLEVBQ2hCQyxhQUFxQixHQUVyQixNQUFNYiwwREFBcUIsQ0FBQztRQUMxQmUsS0FBSyxFQUFFO1lBQUVDLG9CQUFvQixFQUFFLENBQUNILGFBQWE7WUFBRUksZUFBZSxFQUFFTCxRQUFRO1NBQUU7S0FDM0UsQ0FBQyxDQUFDO0FBRUUsTUFBTU0sc0JBQXNCLEdBQUcsT0FBT0MsT0FBZSxHQUMxRCxNQUFNbkIsMERBQXFCLENBQUM7UUFBRWUsS0FBSyxFQUFFO1lBQUVLLGFBQWEsRUFBRUQsT0FBTztTQUFFO0tBQUUsQ0FBQyxDQUFDO0FBRTlELE1BQU1FLDBCQUEwQixHQUFHLE9BQ3hDVCxRQUFnQixFQUNoQkMsYUFBcUIsRUFDckJPLGFBQXFCLEdBQ2xCO0lBQ0gsT0FBTyxNQUFNcEIsdURBQWtCLENBQUM7UUFDOUJlLEtBQUssRUFBRTtZQUNMUSxvQ0FBb0MsRUFBRTtnQkFDcENOLGVBQWUsRUFBRUwsUUFBUTtnQkFDekJJLG9CQUFvQixFQUFFSCxhQUFhO2FBQ3BDO1NBQ0Y7UUFDREwsSUFBSSxFQUFFO1lBQ0pZLGFBQWE7U0FDZDtLQUNGLENBQUMsQ0FBQztDQUNKLENBQUM7QUFDSyxNQUFNSSx1QkFBdUIsR0FBRyxPQUNyQ1osUUFBZ0IsRUFDaEJDLGFBQXFCLEVBQ3JCTyxhQUFxQixHQUNsQjtJQUNILE1BQU1wQiwwREFBa0IsQ0FBQztRQUN2QmUsS0FBSyxFQUFFO1lBQ0xRLG9DQUFvQyxFQUFFO2dCQUNwQ1Asb0JBQW9CLEVBQUVILGFBQWE7Z0JBQ25DSSxlQUFlLEVBQUVMLFFBQVE7YUFDMUI7U0FDRjtLQUNGLENBQUMsQ0FBQztJQUNILE9BQU8sTUFBTVosdURBQWtCLENBQUM7UUFDOUJlLEtBQUssRUFBRTtZQUFFSyxhQUFhO1NBQUU7UUFDeEJPLE1BQU0sRUFBRTtZQUNOVixlQUFlLEVBQUVMLFFBQVE7WUFDekJJLG9CQUFvQixFQUFFSCxhQUFhO1lBQ25DTyxhQUFhO1NBQ2Q7UUFDREUsTUFBTSxFQUFFO1lBQUVOLG9CQUFvQixFQUFFSCxhQUFhO1lBQUVJLGVBQWUsRUFBRUwsUUFBUTtTQUFFO0tBQzNFLENBQUMsQ0FBQztDQUNKLENBQUM7QUFFSyxNQUFNZ0IsdUJBQXVCLEdBQUcsT0FDckNsQixJQUF5QixFQUN6Qm1CLEtBQWlDLEdBQzlCO0lBQ0gsT0FBTyxNQUFNN0IsdURBQWtCLENBQUM7UUFDOUJlLEtBQUssRUFBRTtZQUNMUSxvQ0FBb0MsRUFBRTtnQkFDcENOLGVBQWUsRUFBRVAsSUFBSSxDQUFDRSxRQUFRO2dCQUM5Qkksb0JBQW9CLEVBQUUsQ0FBQ04sSUFBSSxDQUFDRyxhQUFhO2FBQzFDO1NBQ0Y7UUFDRGMsTUFBTSxFQUFFO1lBQ05WLGVBQWUsRUFBRVAsSUFBSSxDQUFDRSxRQUFRO1lBQzlCSSxvQkFBb0IsRUFBRSxDQUFDTixJQUFJLENBQUNHLGFBQWE7WUFDekNpQixTQUFTLEVBQUUsS0FBSztZQUNoQnZCLFdBQVcsRUFBRXNCLEtBQUssQ0FBQ0UsWUFBWTtZQUMvQkMsWUFBWSxFQUFFSCxLQUFLLENBQUNJLGFBQWE7U0FDbEM7UUFDRFgsTUFBTSxFQUFFO1lBQ05RLFNBQVMsRUFBRSxLQUFLO1lBQ2hCdkIsV0FBVyxFQUFFc0IsS0FBSyxDQUFDRSxZQUFZO1lBQy9CQyxZQUFZLEVBQUVILEtBQUssQ0FBQ0ksYUFBYTtTQUNsQztLQUNGLENBQUMsQ0FBQztDQUNKLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9zZXJ2aWNlcy91c2VyLnNlcnZpY2UudHM/ZjNhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0QXBpUmVxdWVzdCB9IGZyb20gXCJuZXh0XCI7XG5pbXBvcnQgeyBBQ0NFU1NfVE9LRU5fQ09PS0lFX0tFWSB9IGZyb20gXCIuLi9jb25zdGFudHMvY29uZmlndXJhdGlvblwiO1xuaW1wb3J0IHsgcHJpc21hIH0gZnJvbSBcIi4uL2xpYi9kYlwiO1xuaW1wb3J0IHsgZGVjcnlwdEFjY2Vzc1Rva2VuIH0gZnJvbSBcIi4uL3V0aWxzL1N0cmluZy51dGlsc1wiO1xuaW1wb3J0IHsgZ2V0VXNlckJ5QWNjZXNzVG9rZW4gfSBmcm9tIFwiLi9kaXNjb3JkLnNlcnZpY2VcIjtcbmltcG9ydCB7IGVycm9yUmVzcG9uc2UsIHN1Y2Nlc3NSZXNwb25zZSB9IGZyb20gXCIuLi91dGlscy9SZXNwb25zZS51dGlsc1wiO1xuaW1wb3J0IHtcbiAgRGlzY29yZEFjY2Vzc1Rva2VuUmVzcG9uc2UsXG4gIERpc2NvcmRVc2VyUmVzcG9uc2UsXG4gIE5leHRPckluY29taW5nTWVzc2FnZSxcbn0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBnZXRBY2Nlc3NUb2tlbkZyb21Db29raWUgfSBmcm9tIFwiLi4vdXRpbHMvUmVxdWVzdC51dGlsc1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0TG9nZ2VkSW5Vc2VyID0gYXN5bmMgKHJlcTogTmV4dE9ySW5jb21pbmdNZXNzYWdlKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYWNjZXNzVG9rZW4gPSBnZXRBY2Nlc3NUb2tlbkZyb21Db29raWUocmVxKTtcbiAgICBpZiAoIWFjY2Vzc1Rva2VuIHx8IHR5cGVvZiBhY2Nlc3NUb2tlbiAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBcIkFjY2VzcyBUb2tlbiBOb3QgRm91bmRcIiB9O1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBnZXRVc2VyQnlBY2Nlc3NUb2tlbihhY2Nlc3NUb2tlbik7XG4gICAgaWYgKHVzZXIpIHJldHVybiBzdWNjZXNzUmVzcG9uc2UodXNlcik7XG4gICAgcmV0dXJuIGVycm9yUmVzcG9uc2UoXCJFcnJvciBmZXRjaGluZyB1c2VyXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBlcnJvclJlc3BvbnNlKFwiRXJyb3IgZmV0Y2hpbmcgdXNlciA6IFwiICsgZXJyb3IpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VXNlckJ5RGlzY29yZElkZW50aWZpZXJzID0gYXN5bmMgKFxuICB1c2VybmFtZTogc3RyaW5nLFxuICBkaXNjcmltaW5hdG9yOiBzdHJpbmdcbikgPT5cbiAgYXdhaXQgcHJpc21hLnVzZXIuZmluZEZpcnN0KHtcbiAgICB3aGVyZTogeyBkaXNjb3JkRGlzY3JpbWluYXRvcjogK2Rpc2NyaW1pbmF0b3IsIGRpc2NvcmRVc2VybmFtZTogdXNlcm5hbWUgfSxcbiAgfSk7XG5cbmV4cG9ydCBjb25zdCBnZXRVc2VyQnlXYWxsZXRBZGRyZXNzID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT5cbiAgYXdhaXQgcHJpc21hLnVzZXIuZmluZEZpcnN0KHsgd2hlcmU6IHsgd2FsbGV0QWRkcmVzczogYWRkcmVzcyB9IH0pO1xuXG5leHBvcnQgY29uc3QgdXBkYXRlVXNlcldhbGxldEFkZHJlc3NPbGQgPSBhc3luYyAoXG4gIHVzZXJuYW1lOiBzdHJpbmcsXG4gIGRpc2NyaW1pbmF0b3I6IG51bWJlcixcbiAgd2FsbGV0QWRkcmVzczogc3RyaW5nXG4pID0+IHtcbiAgcmV0dXJuIGF3YWl0IHByaXNtYS51c2VyLnVwZGF0ZSh7XG4gICAgd2hlcmU6IHtcbiAgICAgIGRpc2NvcmRVc2VybmFtZV9kaXNjb3JkRGlzY3JpbWluYXRvcjoge1xuICAgICAgICBkaXNjb3JkVXNlcm5hbWU6IHVzZXJuYW1lLFxuICAgICAgICBkaXNjb3JkRGlzY3JpbWluYXRvcjogZGlzY3JpbWluYXRvcixcbiAgICAgIH0sXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICB3YWxsZXRBZGRyZXNzLFxuICAgIH0sXG4gIH0pO1xufTtcbmV4cG9ydCBjb25zdCB1cGRhdGVVc2VyV2FsbGV0QWRkcmVzcyA9IGFzeW5jIChcbiAgdXNlcm5hbWU6IHN0cmluZyxcbiAgZGlzY3JpbWluYXRvcjogbnVtYmVyLFxuICB3YWxsZXRBZGRyZXNzOiBzdHJpbmdcbikgPT4ge1xuICBhd2FpdCBwcmlzbWEudXNlci5kZWxldGUoe1xuICAgIHdoZXJlOiB7XG4gICAgICBkaXNjb3JkVXNlcm5hbWVfZGlzY29yZERpc2NyaW1pbmF0b3I6IHtcbiAgICAgICAgZGlzY29yZERpc2NyaW1pbmF0b3I6IGRpc2NyaW1pbmF0b3IsXG4gICAgICAgIGRpc2NvcmRVc2VybmFtZTogdXNlcm5hbWUsXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xuICByZXR1cm4gYXdhaXQgcHJpc21hLnVzZXIudXBzZXJ0KHtcbiAgICB3aGVyZTogeyB3YWxsZXRBZGRyZXNzIH0sXG4gICAgY3JlYXRlOiB7XG4gICAgICBkaXNjb3JkVXNlcm5hbWU6IHVzZXJuYW1lLFxuICAgICAgZGlzY29yZERpc2NyaW1pbmF0b3I6IGRpc2NyaW1pbmF0b3IsXG4gICAgICB3YWxsZXRBZGRyZXNzLFxuICAgIH0sXG4gICAgdXBkYXRlOiB7IGRpc2NvcmREaXNjcmltaW5hdG9yOiBkaXNjcmltaW5hdG9yLCBkaXNjb3JkVXNlcm5hbWU6IHVzZXJuYW1lIH0sXG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVVzZXJPbkRpc2NvcmRBdXRoID0gYXN5bmMgKFxuICB1c2VyOiBEaXNjb3JkVXNlclJlc3BvbnNlLFxuICBjcmVkczogRGlzY29yZEFjY2Vzc1Rva2VuUmVzcG9uc2VcbikgPT4ge1xuICByZXR1cm4gYXdhaXQgcHJpc21hLnVzZXIudXBzZXJ0KHtcbiAgICB3aGVyZToge1xuICAgICAgZGlzY29yZFVzZXJuYW1lX2Rpc2NvcmREaXNjcmltaW5hdG9yOiB7XG4gICAgICAgIGRpc2NvcmRVc2VybmFtZTogdXNlci51c2VybmFtZSxcbiAgICAgICAgZGlzY29yZERpc2NyaW1pbmF0b3I6ICt1c2VyLmRpc2NyaW1pbmF0b3IsXG4gICAgICB9LFxuICAgIH0sXG4gICAgY3JlYXRlOiB7XG4gICAgICBkaXNjb3JkVXNlcm5hbWU6IHVzZXIudXNlcm5hbWUsXG4gICAgICBkaXNjb3JkRGlzY3JpbWluYXRvcjogK3VzZXIuZGlzY3JpbWluYXRvcixcbiAgICAgIGlzQ3JlYXRvcjogZmFsc2UsXG4gICAgICBhY2Nlc3NUb2tlbjogY3JlZHMuYWNjZXNzX3Rva2VuLFxuICAgICAgcmVmcmVzaFRva2VuOiBjcmVkcy5yZWZyZXNoX3Rva2VuLFxuICAgIH0sXG4gICAgdXBkYXRlOiB7XG4gICAgICBpc0NyZWF0b3I6IGZhbHNlLFxuICAgICAgYWNjZXNzVG9rZW46IGNyZWRzLmFjY2Vzc190b2tlbixcbiAgICAgIHJlZnJlc2hUb2tlbjogY3JlZHMucmVmcmVzaF90b2tlbixcbiAgICB9LFxuICB9KTtcbn07XG4iXSwibmFtZXMiOlsicHJpc21hIiwiZ2V0VXNlckJ5QWNjZXNzVG9rZW4iLCJlcnJvclJlc3BvbnNlIiwic3VjY2Vzc1Jlc3BvbnNlIiwiZ2V0QWNjZXNzVG9rZW5Gcm9tQ29va2llIiwiZ2V0TG9nZ2VkSW5Vc2VyIiwicmVxIiwiYWNjZXNzVG9rZW4iLCJkYXRhIiwiZXJyb3IiLCJ1c2VyIiwiZ2V0VXNlckJ5RGlzY29yZElkZW50aWZpZXJzIiwidXNlcm5hbWUiLCJkaXNjcmltaW5hdG9yIiwiZmluZEZpcnN0Iiwid2hlcmUiLCJkaXNjb3JkRGlzY3JpbWluYXRvciIsImRpc2NvcmRVc2VybmFtZSIsImdldFVzZXJCeVdhbGxldEFkZHJlc3MiLCJhZGRyZXNzIiwid2FsbGV0QWRkcmVzcyIsInVwZGF0ZVVzZXJXYWxsZXRBZGRyZXNzT2xkIiwidXBkYXRlIiwiZGlzY29yZFVzZXJuYW1lX2Rpc2NvcmREaXNjcmltaW5hdG9yIiwidXBkYXRlVXNlcldhbGxldEFkZHJlc3MiLCJkZWxldGUiLCJ1cHNlcnQiLCJjcmVhdGUiLCJ1cGRhdGVVc2VyT25EaXNjb3JkQXV0aCIsImNyZWRzIiwiaXNDcmVhdG9yIiwiYWNjZXNzX3Rva2VuIiwicmVmcmVzaFRva2VuIiwicmVmcmVzaF90b2tlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./services/user.service.ts\n");

/***/ }),

/***/ "(api)/./utils/Request.utils.ts":
/*!********************************!*\
  !*** ./utils/Request.utils.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getAccessTokenFromCookie\": () => (/* binding */ getAccessTokenFromCookie),\n/* harmony export */   \"getHttpCookie\": () => (/* binding */ getHttpCookie)\n/* harmony export */ });\n/* harmony import */ var cookies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cookies */ \"cookies\");\n/* harmony import */ var cookies__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cookies__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _constants_configuration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/configuration */ \"(api)/./constants/configuration.ts\");\n/* harmony import */ var _String_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./String.utils */ \"(api)/./utils/String.utils.ts\");\n\n\n\nconst getAccessTokenFromCookie = (req)=>{\n    const encryptedAccessToken = req.cookies[_constants_configuration__WEBPACK_IMPORTED_MODULE_1__.ACCESS_TOKEN_COOKIE_KEY] || req.headers.token;\n    if (!encryptedAccessToken || typeof encryptedAccessToken !== \"string\") return null;\n    return (0,_String_utils__WEBPACK_IMPORTED_MODULE_2__.decryptAccessToken)(encryptedAccessToken);\n};\nconst getHttpCookie = (req, res)=>new (cookies__WEBPACK_IMPORTED_MODULE_0___default())(req, res);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9SZXF1ZXN0LnV0aWxzLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4QjtBQUN1QztBQUVqQjtBQUU3QyxNQUFNRyx3QkFBd0IsR0FBRyxDQUFDQyxHQUEwQixHQUFLO0lBQ3RFLE1BQU1DLG9CQUFvQixHQUN4QkQsR0FBRyxDQUFDRSxPQUFPLENBQUNMLDZFQUF1QixDQUFDLElBQUlHLEdBQUcsQ0FBQ0csT0FBTyxDQUFDQyxLQUFLO0lBQzNELElBQUksQ0FBQ0gsb0JBQW9CLElBQUksT0FBT0Esb0JBQW9CLEtBQUssUUFBUSxFQUNuRSxPQUFPLElBQUksQ0FBQztJQUNkLE9BQU9ILGlFQUFrQixDQUFDRyxvQkFBb0IsQ0FBQyxDQUFDO0NBQ2pELENBQUM7QUFFSyxNQUFNSSxhQUFhLEdBQUcsQ0FDM0JMLEdBQTBCLEVBQzFCTSxHQUF5QixHQUN0QixJQUFJVixnREFBTyxDQUFDSSxHQUFHLEVBQUVNLEdBQUcsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vdXRpbHMvUmVxdWVzdC51dGlscy50cz8xNTU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb29raWVzIGZyb20gXCJjb29raWVzXCI7XG5pbXBvcnQgeyBBQ0NFU1NfVE9LRU5fQ09PS0lFX0tFWSB9IGZyb20gXCIuLi9jb25zdGFudHMvY29uZmlndXJhdGlvblwiO1xuaW1wb3J0IHsgTmV4dE9ySW5jb21pbmdNZXNzYWdlLCBOZXh0T3JTZXJ2ZXJSZXNwb25zZSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgZGVjcnlwdEFjY2Vzc1Rva2VuIH0gZnJvbSBcIi4vU3RyaW5nLnV0aWxzXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRBY2Nlc3NUb2tlbkZyb21Db29raWUgPSAocmVxOiBOZXh0T3JJbmNvbWluZ01lc3NhZ2UpID0+IHtcbiAgY29uc3QgZW5jcnlwdGVkQWNjZXNzVG9rZW4gPVxuICAgIHJlcS5jb29raWVzW0FDQ0VTU19UT0tFTl9DT09LSUVfS0VZXSB8fCByZXEuaGVhZGVycy50b2tlbjtcbiAgaWYgKCFlbmNyeXB0ZWRBY2Nlc3NUb2tlbiB8fCB0eXBlb2YgZW5jcnlwdGVkQWNjZXNzVG9rZW4gIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIHJldHVybiBkZWNyeXB0QWNjZXNzVG9rZW4oZW5jcnlwdGVkQWNjZXNzVG9rZW4pO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEh0dHBDb29raWUgPSAoXG4gIHJlcTogTmV4dE9ySW5jb21pbmdNZXNzYWdlLFxuICByZXM6IE5leHRPclNlcnZlclJlc3BvbnNlXG4pID0+IG5ldyBDb29raWVzKHJlcSwgcmVzKTtcbiJdLCJuYW1lcyI6WyJDb29raWVzIiwiQUNDRVNTX1RPS0VOX0NPT0tJRV9LRVkiLCJkZWNyeXB0QWNjZXNzVG9rZW4iLCJnZXRBY2Nlc3NUb2tlbkZyb21Db29raWUiLCJyZXEiLCJlbmNyeXB0ZWRBY2Nlc3NUb2tlbiIsImNvb2tpZXMiLCJoZWFkZXJzIiwidG9rZW4iLCJnZXRIdHRwQ29va2llIiwicmVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./utils/Request.utils.ts\n");

/***/ }),

/***/ "(api)/./utils/Response.utils.ts":
/*!*********************************!*\
  !*** ./utils/Response.utils.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"errorResponse\": () => (/* binding */ errorResponse),\n/* harmony export */   \"successResponse\": () => (/* binding */ successResponse)\n/* harmony export */ });\nconst errorResponse = (errorMessage)=>({\n        data: null,\n        error: errorMessage\n    });\nconst successResponse = (data)=>({\n        data,\n        error: null\n    });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9SZXNwb25zZS51dGlscy50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLE1BQU1BLGFBQWEsR0FBRyxDQUFDQyxZQUEwQixHQUFLLENBQUM7UUFDNURDLElBQUksRUFBRSxJQUFJO1FBQ1ZDLEtBQUssRUFBRUYsWUFBWTtLQUNwQixDQUFDLENBQUM7QUFFSSxNQUFNRyxlQUFlLEdBQUcsQ0FBQ0YsSUFBUyxHQUFLLENBQUM7UUFBRUEsSUFBSTtRQUFFQyxLQUFLLEVBQUUsSUFBSTtLQUFFLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL3V0aWxzL1Jlc3BvbnNlLnV0aWxzLnRzPzRhN2MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGVycm9yUmVzcG9uc2UgPSAoZXJyb3JNZXNzYWdlOiBzdHJpbmcgfCBhbnkpID0+ICh7XG4gIGRhdGE6IG51bGwsXG4gIGVycm9yOiBlcnJvck1lc3NhZ2UsXG59KTtcblxuZXhwb3J0IGNvbnN0IHN1Y2Nlc3NSZXNwb25zZSA9IChkYXRhOiBhbnkpID0+ICh7IGRhdGEsIGVycm9yOiBudWxsIH0pO1xuIl0sIm5hbWVzIjpbImVycm9yUmVzcG9uc2UiLCJlcnJvck1lc3NhZ2UiLCJkYXRhIiwiZXJyb3IiLCJzdWNjZXNzUmVzcG9uc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./utils/Response.utils.ts\n");

/***/ }),

/***/ "(api)/./utils/Solidity.utils.ts":
/*!*********************************!*\
  !*** ./utils/Solidity.utils.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getContractFile\": () => (/* binding */ getContractFile)\n/* harmony export */ });\nconst solc = __webpack_require__(/*! solc */ \"solc\");\nfunction getContractFile(name, source) {\n    const input = {\n        language: \"Solidity\",\n        sources: {\n            [name + \".sol\"]: {\n                content: source\n            }\n        },\n        settings: {\n            outputSelection: {\n                \"*\": {\n                    \"*\": [\n                        \"*\"\n                    ]\n                }\n            }\n        }\n    };\n    const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));\n    //   console.log(tempFile);\n    const contractFile = tempFile?.contracts?.[name + \".sol\"]?.[name];\n    const errorsAndWarnings = tempFile?.errors ? tempFile.errors : [];\n    const errors = errorsAndWarnings.filter((e)=>e.severity === \"error\");\n    if (!contractFile || errors.length > 0) throw tempFile.errors;\n    return contractFile;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9Tb2xpZGl0eS51dGlscy50cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBRUEsTUFBTUEsSUFBSSxHQUFRQyxtQkFBTyxDQUFDLGtCQUFNLENBQUM7QUFFMUIsU0FBU0MsZUFBZSxDQUM3QkMsSUFBWSxFQUNaQyxNQUFjLEVBQ1k7SUFDMUIsTUFBTUMsS0FBSyxHQUFHO1FBQ1pDLFFBQVEsRUFBRSxVQUFVO1FBQ3BCQyxPQUFPLEVBQUU7WUFDUCxDQUFDSixJQUFJLEdBQUcsTUFBTSxDQUFDLEVBQUU7Z0JBQ2ZLLE9BQU8sRUFBRUosTUFBTTthQUNoQjtTQUNGO1FBQ0RLLFFBQVEsRUFBRTtZQUNSQyxlQUFlLEVBQUU7Z0JBQ2YsR0FBRyxFQUFFO29CQUNILEdBQUcsRUFBRTt3QkFBQyxHQUFHO3FCQUFDO2lCQUNYO2FBQ0Y7U0FDRjtLQUNGO0lBRUQsTUFBTUMsUUFBUSxHQUFHQyxJQUFJLENBQUNDLEtBQUssQ0FBQyxJQUFLLENBQVdDLE9BQU8sQ0FBQ0YsSUFBSSxDQUFDRyxTQUFTLENBQUNWLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDM0UsMkJBQTJCO0lBRTNCLE1BQU1XLFlBQVksR0FBR0wsUUFBUSxFQUFFTSxTQUFTLEVBQUUsQ0FBQ2QsSUFBSSxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUNBLElBQUksQ0FBQztJQUNqRSxNQUFNZSxpQkFBaUIsR0FBbUJQLFFBQVEsRUFBRVEsTUFBTSxHQUN0RFIsUUFBUSxDQUFDUSxNQUFNLEdBQ2YsRUFBRTtJQUNOLE1BQU1BLE1BQU0sR0FBR0QsaUJBQWlCLENBQUNFLE1BQU0sQ0FBQyxDQUFDQyxDQUFDLEdBQUtBLENBQUMsQ0FBQ0MsUUFBUSxLQUFLLE9BQU8sQ0FBQztJQUN0RSxJQUFJLENBQUNOLFlBQVksSUFBSUcsTUFBTSxDQUFDSSxNQUFNLEdBQUcsQ0FBQyxFQUFFLE1BQU1aLFFBQVEsQ0FBQ1EsTUFBTSxDQUFDO0lBQzlELE9BQU9ILFlBQVksQ0FBQztDQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL3V0aWxzL1NvbGlkaXR5LnV0aWxzLnRzP2IyNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udHJhY3RGaWxlLCBDb21waWxlRXJyb3IgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB0c29sYyBmcm9tIFwidHlwZXMtc29sY1wiO1xuY29uc3Qgc29sYzogYW55ID0gcmVxdWlyZShcInNvbGNcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250cmFjdEZpbGUoXG4gIG5hbWU6IHN0cmluZyxcbiAgc291cmNlOiBzdHJpbmdcbik6IHVuZGVmaW5lZCB8IENvbnRyYWN0RmlsZSB7XG4gIGNvbnN0IGlucHV0ID0ge1xuICAgIGxhbmd1YWdlOiBcIlNvbGlkaXR5XCIsXG4gICAgc291cmNlczoge1xuICAgICAgW25hbWUgKyBcIi5zb2xcIl06IHtcbiAgICAgICAgY29udGVudDogc291cmNlLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHNldHRpbmdzOiB7XG4gICAgICBvdXRwdXRTZWxlY3Rpb246IHtcbiAgICAgICAgXCIqXCI6IHtcbiAgICAgICAgICBcIipcIjogW1wiKlwiXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcblxuICBjb25zdCB0ZW1wRmlsZSA9IEpTT04ucGFyc2UoKHNvbGMgYXMgdHNvbGMpLmNvbXBpbGUoSlNPTi5zdHJpbmdpZnkoaW5wdXQpKSk7XG4gIC8vICAgY29uc29sZS5sb2codGVtcEZpbGUpO1xuXG4gIGNvbnN0IGNvbnRyYWN0RmlsZSA9IHRlbXBGaWxlPy5jb250cmFjdHM/LltuYW1lICsgXCIuc29sXCJdPy5bbmFtZV07XG4gIGNvbnN0IGVycm9yc0FuZFdhcm5pbmdzOiBDb21waWxlRXJyb3JbXSA9IHRlbXBGaWxlPy5lcnJvcnNcbiAgICA/IHRlbXBGaWxlLmVycm9yc1xuICAgIDogW107XG4gIGNvbnN0IGVycm9ycyA9IGVycm9yc0FuZFdhcm5pbmdzLmZpbHRlcigoZSkgPT4gZS5zZXZlcml0eSA9PT0gXCJlcnJvclwiKTtcbiAgaWYgKCFjb250cmFjdEZpbGUgfHwgZXJyb3JzLmxlbmd0aCA+IDApIHRocm93IHRlbXBGaWxlLmVycm9ycztcbiAgcmV0dXJuIGNvbnRyYWN0RmlsZTtcbn1cbiJdLCJuYW1lcyI6WyJzb2xjIiwicmVxdWlyZSIsImdldENvbnRyYWN0RmlsZSIsIm5hbWUiLCJzb3VyY2UiLCJpbnB1dCIsImxhbmd1YWdlIiwic291cmNlcyIsImNvbnRlbnQiLCJzZXR0aW5ncyIsIm91dHB1dFNlbGVjdGlvbiIsInRlbXBGaWxlIiwiSlNPTiIsInBhcnNlIiwiY29tcGlsZSIsInN0cmluZ2lmeSIsImNvbnRyYWN0RmlsZSIsImNvbnRyYWN0cyIsImVycm9yc0FuZFdhcm5pbmdzIiwiZXJyb3JzIiwiZmlsdGVyIiwiZSIsInNldmVyaXR5IiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./utils/Solidity.utils.ts\n");

/***/ }),

/***/ "(api)/./utils/String.utils.ts":
/*!*******************************!*\
  !*** ./utils/String.utils.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bufferTohex\": () => (/* binding */ bufferTohex),\n/* harmony export */   \"capitalize\": () => (/* binding */ capitalize),\n/* harmony export */   \"decryptAccessToken\": () => (/* binding */ decryptAccessToken),\n/* harmony export */   \"encryptToken\": () => (/* binding */ encryptToken),\n/* harmony export */   \"formatHtmlDateTime\": () => (/* binding */ formatHtmlDateTime),\n/* harmony export */   \"getMintEventArgsMapping\": () => (/* binding */ getMintEventArgsMapping),\n/* harmony export */   \"getSaleConfigFromResponse\": () => (/* binding */ getSaleConfigFromResponse),\n/* harmony export */   \"isValidQueryParam\": () => (/* binding */ isValidQueryParam),\n/* harmony export */   \"normalizeString\": () => (/* binding */ normalizeString)\n/* harmony export */ });\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto-js */ \"crypto-js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _constants_configuration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/configuration */ \"(api)/./constants/configuration.ts\");\n\n\nconst isValidQueryParam = (...data)=>{\n    let hasError = false;\n    data.forEach((item)=>{\n        if (!item || typeof item !== \"string\") {\n            hasError = true;\n        }\n    });\n    return !hasError;\n};\nconst decryptAccessToken = (encryptedAccessToken)=>crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.decrypt(encryptedAccessToken, _constants_configuration__WEBPACK_IMPORTED_MODULE_1__.CRYPTO_SECRET).toString((crypto_js__WEBPACK_IMPORTED_MODULE_0___default().enc.Utf8));\nconst encryptToken = (token)=>crypto_js__WEBPACK_IMPORTED_MODULE_0___default().AES.encrypt(token, _constants_configuration__WEBPACK_IMPORTED_MODULE_1__.CRYPTO_SECRET).toString();\nfunction capitalize(input) {\n    return input[0].toUpperCase() + input.slice(1);\n}\nfunction normalizeString(input) {\n    const res = input.split(\" \").map((w)=>capitalize(w)).join(\"\").split(\"-\").map((w)=>capitalize(w)).join(\"_\");\n    console.log(input, \" is nzd to \", res);\n    return input.split(\" \").map((w)=>capitalize(w)).join(\"\").split(\"-\").map((w)=>capitalize(w)).join(\"\");\n//   return capitalize(input).replace(\" \", \"_\").replace(\"-\", \"_\");\n}\nconst bufferTohex = (buf)=>`0x${buf.toString(\"hex\")}`;\nconst getSaleConfigFromResponse = (data)=>({\n        status: data[\"status\"],\n        startTime: +data[\"startTime\"].toString(),\n        endTime: +data[\"endTime\"].toString()\n    });\nconst getMintEventArgsMapping = (data)=>({\n        msgSender: data[\"msgSender\"],\n        tokenId: +data[\"tokenId\"].toString(),\n        tokenUri: data[\"tokenUri\"]\n    });\nfunction forceTwo(inp) {\n    return inp.toString().padStart(2, \"0\");\n}\nfunction formatHtmlDateTime(datetime) {\n    return `${datetime.getFullYear()}-${forceTwo(datetime.getMonth() + 1)}-${forceTwo(datetime.getDate())}T${forceTwo(datetime.getHours())}:${forceTwo(datetime.getMinutes())}`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi91dGlscy9TdHJpbmcudXRpbHMudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDO0FBQzBCO0FBRXBELE1BQU1FLGlCQUFpQixHQUFHLENBQy9CLEdBQUdDLElBQUksR0FDSjtJQUNILElBQUlDLFFBQVEsR0FBRyxLQUFLO0lBQ3BCRCxJQUFJLENBQUNFLE9BQU8sQ0FBQyxDQUFDQyxJQUFJLEdBQUs7UUFDckIsSUFBSSxDQUFDQSxJQUFJLElBQUksT0FBT0EsSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUNyQ0YsUUFBUSxHQUFHLElBQUksQ0FBQztTQUNqQjtLQUNGLENBQUMsQ0FBQztJQUNILE9BQU8sQ0FBQ0EsUUFBUSxDQUFDO0NBQ2xCLENBQUM7QUFFSyxNQUFNRyxrQkFBa0IsR0FBRyxDQUFDQyxvQkFBNEIsR0FDN0RSLDREQUFvQixDQUFDUSxvQkFBb0IsRUFBRVAsbUVBQWEsQ0FBQyxDQUFDVSxRQUFRLENBQ2hFWCwyREFBaUIsQ0FDbEIsQ0FBQztBQUVHLE1BQU1jLFlBQVksR0FBRyxDQUFDQyxLQUFhLEdBQ3hDZiw0REFBb0IsQ0FBQ2UsS0FBSyxFQUFFZCxtRUFBYSxDQUFDLENBQUNVLFFBQVEsRUFBRSxDQUFDO0FBRWpELFNBQVNNLFVBQVUsQ0FBQ0MsS0FBYSxFQUFFO0lBQ3hDLE9BQU9BLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQ0MsV0FBVyxFQUFFLEdBQUdELEtBQUssQ0FBQ0UsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ2hEO0FBRU0sU0FBU0MsZUFBZSxDQUFDSCxLQUFhLEVBQUU7SUFDN0MsTUFBTUksR0FBRyxHQUFHSixLQUFLLENBQ2RLLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FDVkMsR0FBRyxDQUFDLENBQUNDLENBQUMsR0FBS1IsVUFBVSxDQUFDUSxDQUFDLENBQUMsQ0FBQyxDQUN6QkMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUNSSCxLQUFLLENBQUMsR0FBRyxDQUFDLENBQ1ZDLEdBQUcsQ0FBQyxDQUFDQyxDQUFDLEdBQUtSLFVBQVUsQ0FBQ1EsQ0FBQyxDQUFDLENBQUMsQ0FDekJDLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDWkMsT0FBTyxDQUFDQyxHQUFHLENBQUNWLEtBQUssRUFBRSxhQUFhLEVBQUVJLEdBQUcsQ0FBQyxDQUFDO0lBRXZDLE9BQU9KLEtBQUssQ0FDVEssS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUNWQyxHQUFHLENBQUMsQ0FBQ0MsQ0FBQyxHQUFLUixVQUFVLENBQUNRLENBQUMsQ0FBQyxDQUFDLENBQ3pCQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQ1JILEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FDVkMsR0FBRyxDQUFDLENBQUNDLENBQUMsR0FBS1IsVUFBVSxDQUFDUSxDQUFDLENBQUMsQ0FBQyxDQUN6QkMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ1osa0VBQWtFO0NBQ25FO0FBRU0sTUFBTUcsV0FBVyxHQUFHLENBQUNDLEdBQVcsR0FBSyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDbkIsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUVoRSxNQUFNb0IseUJBQXlCLEdBQUcsQ0FBQzVCLElBQTBCLEdBQUssQ0FBQztRQUN4RTZCLE1BQU0sRUFBRTdCLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdEI4QixTQUFTLEVBQUUsQ0FBQzlCLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQ1EsUUFBUSxFQUFFO1FBQ3hDdUIsT0FBTyxFQUFFLENBQUMvQixJQUFJLENBQUMsU0FBUyxDQUFDLENBQUNRLFFBQVEsRUFBRTtLQUNyQyxDQUFDLENBQUM7QUFFSSxNQUFNd0IsdUJBQXVCLEdBQUcsQ0FBQ2hDLElBQTBCLEdBQUssQ0FBQztRQUN0RWlDLFNBQVMsRUFBRWpDLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDNUJrQyxPQUFPLEVBQUUsQ0FBQ2xDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQ1EsUUFBUSxFQUFFO1FBQ3BDMkIsUUFBUSxFQUFFbkMsSUFBSSxDQUFDLFVBQVUsQ0FBQztLQUMzQixDQUFDLENBQUM7QUFFSCxTQUFTb0MsUUFBUSxDQUFDQyxHQUFXLEVBQUU7SUFDN0IsT0FBT0EsR0FBRyxDQUFDN0IsUUFBUSxFQUFFLENBQUM4QixRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0NBQ3hDO0FBRU0sU0FBU0Msa0JBQWtCLENBQUNDLFFBQWMsRUFBRTtJQUNqRCxPQUFPLENBQUMsRUFBRUEsUUFBUSxDQUFDQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLEVBQUVMLFFBQVEsQ0FDMUNJLFFBQVEsQ0FBQ0UsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUN4QixDQUFDLENBQUMsRUFBRU4sUUFBUSxDQUFDSSxRQUFRLENBQUNHLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFUCxRQUFRLENBQzNDSSxRQUFRLENBQUNJLFFBQVEsRUFBRSxDQUNwQixDQUFDLENBQUMsRUFBRVIsUUFBUSxDQUFDSSxRQUFRLENBQUNLLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ3hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vdXRpbHMvU3RyaW5nLnV0aWxzLnRzPzQ3MzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENyeXB0b0pTIGZyb20gXCJjcnlwdG8tanNcIjtcbmltcG9ydCB7IENSWVBUT19TRUNSRVQgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2NvbmZpZ3VyYXRpb25cIjtcblxuZXhwb3J0IGNvbnN0IGlzVmFsaWRRdWVyeVBhcmFtID0gKFxuICAuLi5kYXRhOiAoc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQpW11cbikgPT4ge1xuICBsZXQgaGFzRXJyb3IgPSBmYWxzZTtcbiAgZGF0YS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaWYgKCFpdGVtIHx8IHR5cGVvZiBpdGVtICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICFoYXNFcnJvcjtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWNyeXB0QWNjZXNzVG9rZW4gPSAoZW5jcnlwdGVkQWNjZXNzVG9rZW46IHN0cmluZykgPT5cbiAgQ3J5cHRvSlMuQUVTLmRlY3J5cHQoZW5jcnlwdGVkQWNjZXNzVG9rZW4sIENSWVBUT19TRUNSRVQpLnRvU3RyaW5nKFxuICAgIENyeXB0b0pTLmVuYy5VdGY4XG4gICk7XG5cbmV4cG9ydCBjb25zdCBlbmNyeXB0VG9rZW4gPSAodG9rZW46IHN0cmluZykgPT5cbiAgQ3J5cHRvSlMuQUVTLmVuY3J5cHQodG9rZW4sIENSWVBUT19TRUNSRVQpLnRvU3RyaW5nKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXBpdGFsaXplKGlucHV0OiBzdHJpbmcpIHtcbiAgcmV0dXJuIGlucHV0WzBdLnRvVXBwZXJDYXNlKCkgKyBpbnB1dC5zbGljZSgxKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZyhpbnB1dDogc3RyaW5nKSB7XG4gIGNvbnN0IHJlcyA9IGlucHV0XG4gICAgLnNwbGl0KFwiIFwiKVxuICAgIC5tYXAoKHcpID0+IGNhcGl0YWxpemUodykpXG4gICAgLmpvaW4oXCJcIilcbiAgICAuc3BsaXQoXCItXCIpXG4gICAgLm1hcCgodykgPT4gY2FwaXRhbGl6ZSh3KSlcbiAgICAuam9pbihcIl9cIik7XG4gIGNvbnNvbGUubG9nKGlucHV0LCBcIiBpcyBuemQgdG8gXCIsIHJlcyk7XG5cbiAgcmV0dXJuIGlucHV0XG4gICAgLnNwbGl0KFwiIFwiKVxuICAgIC5tYXAoKHcpID0+IGNhcGl0YWxpemUodykpXG4gICAgLmpvaW4oXCJcIilcbiAgICAuc3BsaXQoXCItXCIpXG4gICAgLm1hcCgodykgPT4gY2FwaXRhbGl6ZSh3KSlcbiAgICAuam9pbihcIlwiKTtcbiAgLy8gICByZXR1cm4gY2FwaXRhbGl6ZShpbnB1dCkucmVwbGFjZShcIiBcIiwgXCJfXCIpLnJlcGxhY2UoXCItXCIsIFwiX1wiKTtcbn1cblxuZXhwb3J0IGNvbnN0IGJ1ZmZlclRvaGV4ID0gKGJ1ZjogQnVmZmVyKSA9PiBgMHgke2J1Zi50b1N0cmluZyhcImhleFwiKX1gO1xuXG5leHBvcnQgY29uc3QgZ2V0U2FsZUNvbmZpZ0Zyb21SZXNwb25zZSA9IChkYXRhOiB7IFt4OiBzdHJpbmddOiBhbnkgfSkgPT4gKHtcbiAgc3RhdHVzOiBkYXRhW1wic3RhdHVzXCJdLFxuICBzdGFydFRpbWU6ICtkYXRhW1wic3RhcnRUaW1lXCJdLnRvU3RyaW5nKCksXG4gIGVuZFRpbWU6ICtkYXRhW1wiZW5kVGltZVwiXS50b1N0cmluZygpLFxufSk7XG5cbmV4cG9ydCBjb25zdCBnZXRNaW50RXZlbnRBcmdzTWFwcGluZyA9IChkYXRhOiB7IFt4OiBzdHJpbmddOiBhbnkgfSkgPT4gKHtcbiAgbXNnU2VuZGVyOiBkYXRhW1wibXNnU2VuZGVyXCJdLFxuICB0b2tlbklkOiArZGF0YVtcInRva2VuSWRcIl0udG9TdHJpbmcoKSxcbiAgdG9rZW5Vcmk6IGRhdGFbXCJ0b2tlblVyaVwiXSxcbn0pO1xuXG5mdW5jdGlvbiBmb3JjZVR3byhpbnA6IG51bWJlcikge1xuICByZXR1cm4gaW5wLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0SHRtbERhdGVUaW1lKGRhdGV0aW1lOiBEYXRlKSB7XG4gIHJldHVybiBgJHtkYXRldGltZS5nZXRGdWxsWWVhcigpfS0ke2ZvcmNlVHdvKFxuICAgIGRhdGV0aW1lLmdldE1vbnRoKCkgKyAxXG4gICl9LSR7Zm9yY2VUd28oZGF0ZXRpbWUuZ2V0RGF0ZSgpKX1UJHtmb3JjZVR3byhcbiAgICBkYXRldGltZS5nZXRIb3VycygpXG4gICl9OiR7Zm9yY2VUd28oZGF0ZXRpbWUuZ2V0TWludXRlcygpKX1gO1xufVxuIl0sIm5hbWVzIjpbIkNyeXB0b0pTIiwiQ1JZUFRPX1NFQ1JFVCIsImlzVmFsaWRRdWVyeVBhcmFtIiwiZGF0YSIsImhhc0Vycm9yIiwiZm9yRWFjaCIsIml0ZW0iLCJkZWNyeXB0QWNjZXNzVG9rZW4iLCJlbmNyeXB0ZWRBY2Nlc3NUb2tlbiIsIkFFUyIsImRlY3J5cHQiLCJ0b1N0cmluZyIsImVuYyIsIlV0ZjgiLCJlbmNyeXB0VG9rZW4iLCJ0b2tlbiIsImVuY3J5cHQiLCJjYXBpdGFsaXplIiwiaW5wdXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwibm9ybWFsaXplU3RyaW5nIiwicmVzIiwic3BsaXQiLCJtYXAiLCJ3Iiwiam9pbiIsImNvbnNvbGUiLCJsb2ciLCJidWZmZXJUb2hleCIsImJ1ZiIsImdldFNhbGVDb25maWdGcm9tUmVzcG9uc2UiLCJzdGF0dXMiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiZ2V0TWludEV2ZW50QXJnc01hcHBpbmciLCJtc2dTZW5kZXIiLCJ0b2tlbklkIiwidG9rZW5VcmkiLCJmb3JjZVR3byIsImlucCIsInBhZFN0YXJ0IiwiZm9ybWF0SHRtbERhdGVUaW1lIiwiZGF0ZXRpbWUiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./utils/String.utils.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("(api)/./pages/api/v1/contract/collection721.ts"));
module.exports = __webpack_exports__;

})();